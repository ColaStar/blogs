(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{414:function(n,s,e){"use strict";e.r(s);var t=e(42),a=Object(t.a)({},(function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("同一个标识符的情况下，变量声明与函数声明都会提升；函数声明会覆盖变量声明，但不会覆盖变量赋值，即：如果声明变量的同时初始化或赋值那么变量优先级高于函数")]),n._v(" "),e("p",[n._v('函式表达式中函数的识别名是可以不需要有的，有名称的函数表达式，也就是所谓的"具名函数表达式"(Named function expressions，NFE)，这个函数的识别名，它的作用域是只能在函数的主体(FunctionBody)内部。原因当然它只是个原本就可有可无的"代理"函数名，真正的这函数识别名称是被赋值的那个变量识别名。')]),n._v(" "),e("p",[n._v('正常情况下，你只能在函数表述式中的主体中使用这个"代理函数名"，这也是符合标准的规定，如下面的例子:')]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('var f = function foo(){\n  return typeof foo; \n};\ntypeof foo; // "undefined"\nf(); // "function"\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br")])])])}),[],!1,null,null,null);s.default=a.exports}}]);