(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{137:function(o,e,n){"use strict";n.r(e);var m=n(0),p=Object(m.a)({},function(){var o=this,e=o.$createElement,n=o._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[n("p",[o._v("深入 CommonJs 与 ES6 Module\n目前主流的模块规范")]),o._v(" "),n("p",[o._v("UMD\nCommonJs\nes6 module\numd 模块（通用模块）")]),o._v(" "),n("p",[o._v("(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global.libName = factory());\n}(this, (function () { 'use strict';})));\n如果你在js文件头部看到这样的代码，那么这个文件使用的就是 UMD 规范\n实际上就是 amd + commonjs + 全局变量 这三种风格的结合\n这段代码就是对当前运行环境的判断，如果是 Node 环境 就是使用 CommonJs 规范， 如果不是就判断是否为 AMD 环境， 最后导出全局变量\n有了 UMD 后我们的代码和同时运行在 Node 和 浏览器上\n所以现在前端大多数的库最后打包都使用的是 UMD 规范")]),o._v(" "),n("p",[o._v("CommonJs\nNodejs 环境所使用的模块系统就是基于CommonJs规范实现的，我们现在所说的CommonJs规范也大多是指Node的模块系统")]),o._v(" "),n("p",[o._v("模块导出\n关键字：module.exports exports")]),o._v(" "),n("p",[o._v("// foo.js")]),o._v(" "),n("p",[o._v("//一个一个 导出\nmodule.exports.age = 1\nmodule.exports.foo = function(){}\nexports.a = 'hello'")]),o._v(" "),n("p",[o._v("//整体导出\nmodule.exports = { age: 1, a: 'hello', foo:function(){} }")]),o._v(" "),n("p",[o._v("//整体导出不能用"),n("code",[o._v("exports")]),o._v(" 用exports不能在导入的时候使用\nexports = { age: 1, a: 'hello', foo:function(){} }\n这里需要注意 exports 不能被赋值，可以理解为在模块开始前exports = module.exports， 因为赋值之后exports失去了 对module.exports的引用，成为了一个模块内的局部变量")]),o._v(" "),n("p",[o._v("模块导入\n关键字：require")]),o._v(" "),n("p",[o._v("const foo = require('./foo.js')\nconsole.log(foo.age) //1\n模块导入规则：\n假设以下目录为 src/app/index.js 的文件 调用 require()")]),o._v(" "),n("p",[o._v("./moduleA 相对路径开头\n在没有指定后缀名的情况下\n先去寻找同级目录同级目录：src/app/")]),o._v(" "),n("p",[o._v("src/app/moduleA 无后缀名文件 按照javascript解析\nsrc/app/moduleA.js js文件 按照javascript解析\nsrc/app/moduleA.json json文件 按照json解析\nsrc/app/moduleA.node node文件 按照加载的编译插件模块dlopen\n同级目录没有 moduleA 文件会去找同级的 moduleA目录：src/app/moduleA")]),o._v(" "),n("p",[o._v("src/app/moduleA/package.json 判断该目录是否有package.json文件， 如果有 找到main字段定义的文件返回， 如果 main 字段指向文件不存在 或 main字段不存在 或 package.json文件不存在向下执行\nsrc/app/moduleA/index.js\nsrc/app/moduleA/index.json\nsrc/app/moduleA/index.node\n结束")]),o._v(" "),n("p",[o._v("/module/moduleA 绝对路径开头\n直接在/module/moduleA目录中寻找 规则同上")]),o._v(" "),n("p",[o._v("react 没有路径开头\n没有路径开头则视为导入一个包\n会先判断moduleA是否是一个核心模块 如path，http，优先导入核心模块\n不是核心模块 会从当前文件的同级目录的node_modules寻找")]),o._v(" "),n("p",[o._v("/src/app/node_modules/ 寻找规则同上 以导入react为例 先 node_modules 下 react 文件 -> react.js -> react.json -> react.node ->react目录 -> react package.json main -> index.js -> index.json -> index.node 如果没找到 继续向父目录的node_modules中找\n/src/node_modules/\n/node_modules/\n直到最后找不到 结束")]),o._v(" "),n("p",[o._v("require wrapper\nNode的模块 实际上可以理解为代码被包裹在一个函数包装器内\n一个简单的require demo：")]),o._v(" "),n("p",[o._v("function wrapper (script) {\nreturn '(function (exports, require, module, __filename, __dirname) {' +\nscript +\n'\\n})'\n}")]),o._v(" "),n("p",[o._v("function require(id) {\nvar cachedModule = Module._cache[id];\nif(cachedModule){\nreturn cachedModule.exports;\n}")]),o._v(" "),n("p",[o._v("const module = { exports: {} }")]),o._v(" "),n("p",[o._v("// 这里先将引用加入缓存 后面循环引用会说到\nModule._cache[id] = module")]),o._v(" "),n("p",[o._v("//当然不是eval这么简单\neval(wrapper('module.exports = \"123\"'))(module.exports, require, module, 'filename', 'dirname')")]),o._v(" "),n("p",[o._v("return module.exports\n}\n也可以查看：node module 源码\n从以上代码我们可以知道：")]),o._v(" "),n("p",[o._v("模块只执行一次 之后调用获取的 module.exports 都是缓存哪怕这个 js 还没执行完毕（因为先加入缓存后执行模块）\n模块导出就是return这个变量的其实跟a = b赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址\nexports 和 module.exports 持有相同引用，因为最后导出的是 module.exports， 所以对exports进行赋值会导致exports操作的不再是module.exports的引用\n循环引用")]),o._v(" "),n("p",[o._v("// a.js\nmodule.exports.a = 1\nvar b = require('./b')\nconsole.log(b)\nmodule.exports.a = 2")]),o._v(" "),n("p",[o._v("// b.js\nmodule.exports.b = 11\nvar a = require('./a')\nconsole.log(a)\nmodule.exports.b = 22")]),o._v(" "),n("p",[o._v("//main.js\nvar a = require('./a')\nconsole.log(a)\n运行此段代码结合上面的require demo，分析每一步过程：")]),o._v(" "),n("p",[o._v("执行 node main.js -> 第一行 require(a.js)，（node 执行也可以理解为调用了require方法，我们省略require(main.js)内容）\n进入 require(a)方法： 判断缓存（无） -> 初始化一个 module -> 将 module 加入缓存 -> 执行模块 a.js 内容，（需要注意 是先加入缓存， 后执行模块内容）\na.js： 第一行导出 a = 1 -> 第二行 require(b.js)（a 只执行了第一行）\n进入 require(b) 内 同 1 -> 执行模块 b.js 内容\nb.js： 第一行 b = 11 -> 第二行 require(a.js)\nrequire(a) 此时 a.js 是第二次调用 require -> 判断缓存（有）-> cachedModule.exports -> 回到 b.js（因为js对象引用问题 此时的 cachedModule.exports = { a: 1 }）\nb.js：第三行 输出 { a: 1 } -> 第四行 修改 b = 22 -> 执行完毕回到 a.js\na.js：第二行 require 完毕 获取到 b -> 第三行 输出 { b: 22 } -> 第四行 导出 a = 2 -> 执行完毕回到 main.js\nmain.js：获取 a -> 第二行 输出 { a: 2 } -> 执行完毕\n以上就是node的module模块解析和运行的大致规则")]),o._v(" "),n("p",[o._v("es6 module\nES6 之前 javascript 一直没有属于自己的模块规范，所以社区制定了 CommonJs规范， Node 从 Commonjs 规范中借鉴了思想于是有了 Node 的 module，而 AMD 异步模块 也同样脱胎于 Commonjs 规范，之后有了运行在浏览器上的 require.js")]),o._v(" "),n("p",[o._v("es6 module 基本语法：")]),o._v(" "),n("p",[o._v("export")]),o._v(" "),n("p",[o._v("export * from 'module'; //重定向导出 不包括 module内的default\nexport { name1, name2, ..., nameN } from 'module'; // 重定向命名导出\nexport { import1 as name1, import2 as name2, ..., nameN } from 'module'; // 重定向重命名导出")]),o._v(" "),n("p",[o._v("export { name1, name2, …, nameN }; // 与之前声明的变量名绑定 命名导出\nexport { variable1 as name1, variable2 as name2, …, nameN }; // 重命名导出")]),o._v(" "),n("p",[o._v("export let name1 = 'name1'; // 声明命名导出 或者 var, const，function， function*, class")]),o._v(" "),n("p",[o._v("export default expression; // 默认导出\nexport default function () { ... } // 或者 function*, class\nexport default function name1() { ... } // 或者 function*, class\nexport { name1 as default, ... }; // 重命名为默认导出\nexport 规则")]),o._v(" "),n("p",[o._v("export * from '' 或者 export {} from ''，重定向导出，重定向的命名并不能在本模块使用，只是搭建一个桥梁，例如：这个a并不能在本模块内使用\nexport {}， 与变量名绑定，命名导出\nexport Declaration，声明的同时，命名导出， Declaration就是： var, let, const, function, function*, class 这一类的声明语句\nexport default AssignmentExpression，默认导出， AssignmentExpression的 范围很广，可以大致理解 为除了声明Declaration（其实两者是有交叉的），a=2,i++,i/4,a===b,obj[name],name in obj,func(),new P(),[1,2,3],function(){}等等很多\nimport")]),o._v(" "),n("p",[o._v("// 命名导出 module.js\nlet a = 1,b = 2\nexport { a, b }\nexport let c = 3")]),o._v(" "),n("p",[o._v("// 命名导入 main.js\nimport { a, b, c } from 'module'; // a: 1  b: 2  c: 3\nimport { a as newA, b, c as newC } from 'module'; // newA: 1  b: 2  newC: 3")]),o._v(" "),n("p",[o._v("// 默认导出 module.js\nexport default 1")]),o._v(" "),n("p",[o._v("// 默认导入 main.js\nimport defaultExport from 'module'; // defaultExport: 1")]),o._v(" "),n("p",[o._v("// 混合导出 module.js\nlet a = 1\nexport { a }\nconst b = 2\nexport { b }\nexport let c = 3\nexport default [1, 2, 3]")]),o._v(" "),n("p",[o._v("// 混合导入 main.js\nimport defaultExport, { a, b, c as newC} from 'module'; //defaultExport: [1, 2, 3]  a: 1  b: 2  newC: 3\nimport defaultExport, * as name from 'module'; //defaultExport: [1, 2, 3]  name: { a: 1, b: 2, c: 3 }\nimport * as name from 'module'; // name: { a: 1, b: 2, c: 3, default: [1, 2, 3] }")]),o._v(" "),n("p",[o._v("// module.js\nArray.prototype.remove = function(){}")]),o._v(" "),n("p",[o._v("//副作用 只运行一个模块\nimport 'module'; // 执行module 不导出值  多次调用module.js只运行一次")]),o._v(" "),n("p",[o._v("//动态导入(异步导入)\nvar promise = import('module');\nimport 规则\nimport { } from 'module'， 导入module.js的命名导出\nimport defaultExport from 'module'， 导入module.js的默认导出\nimport * as name from 'module'， 将module.js的的所有导出合并为name的对象，key为导出的命名，默认导出的key为default\nimport 'module'，副作用，只是运行module，不为了导出内容例如 polyfill，多次调用次语句只能执行一次\nimport('module')，动态导入返回一个 Promise，TC39的stage-3阶段被提出 tc39 import\nES6 module 特点\nES6 module的语法是静态的\nimport 会自动提升到代码的顶层")]),o._v(" "),n("p",[o._v("export 和 import 只能出现在代码的顶层，下面这段语法是错误的")]),o._v(" "),n("p",[o._v("//if for while 等都无法使用\n{\nexport let a = 1")]),o._v(" "),n("p",[o._v("import defaultExport from 'module'\n}")]),o._v(" "),n("p",[o._v("true || export let a = 1\nimport 的导入名不能为字符串或在判断语句，下面代码是错误的")]),o._v(" "),n("p",[o._v("import 'defaultExport' from 'module'")]),o._v(" "),n("p",[o._v("let name = 'Export'\nimport 'default' + name from 'module'\n静态的语法意味着可以在编译时确定导入和导出，更加快速的查找依赖，可以使用lint工具对模块依赖进行检查，可以对导入导出加上类型信息进行静态的类型检查")]),o._v(" "),n("p",[o._v("ES6 module的导出是绑定的\n使用 import 被导入的模块运行在严格模式下")]),o._v(" "),n("p",[o._v("使用 import 被导入的变量是只读的，可以理解默认为 const 装饰，无法被赋值")]),o._v(" "),n("p",[o._v("使用 import 被导入的变量是与原变量绑定/引用的，可以理解为 import 导入的变量无论是否为基本类型都是引用传递")]),o._v(" "),n("p",[o._v("// js中 基础类型是值传递\nlet a = 1\nlet b = a\nb = 2\nconsole.log(a,b) //1 2")]),o._v(" "),n("p",[o._v("// js中 引用类型是引用传递\nlet obj = {name:'obj'}\nlet obj2 = obj\nobj2.name = 'obj2'\nconsole.log(obj.name, obj2.name) // obj2  obj2")]),o._v(" "),n("p",[o._v("// es6 module 中基本类型也按引用传递\n// foo.js\nexport let a = 1\nexport function count(){\na++\n}")]),o._v(" "),n("p",[o._v("// main.js\nimport { a, count } from './foo'\nconsole.log(a) //1\ncount()\nconsole.log(a) //2\n上面这段代码就是 CommonJs 导出变量 和 ES6 导出变量的区别")]),o._v(" "),n("p",[o._v("es module 循环引用")]),o._v(" "),n("p",[o._v("// bar.js\nimport { foo } from './foo'\nconsole.log(foo);\nexport let bar = 'bar'")]),o._v(" "),n("p",[o._v("// foo.js\nimport { bar } from './bar'\nconsole.log(bar);\nexport let foo = 'foo'")]),o._v(" "),n("p",[o._v("// main.js\nimport { bar } from './bar'\nconsole.log(bar)\n执行 main.js -> 导入 bar.js\nbar.js -> 导入 foo.js\nfoo.js -> 导入 bar.js -> bar.js 已经执行过直接返回 -> 输出 bar -> bar is not defined， bar 未定义报错\n我们可以使用function的方式解决：")]),o._v(" "),n("p",[o._v("// bar.js\nimport { foo } from './foo'\nconsole.log(foo());\nexport function bar(){\nreturn 'bar'\n}")]),o._v(" "),n("p",[o._v("// foo.js\nimport { bar } from './bar'\nconsole.log(bar());\nexport function foo(){\nreturn 'foo'\n}")]),o._v(" "),n("p",[o._v("// main.js\nimport { bar } from './bar'\nconsole.log(bar)\n因为函数声明会提示到文件顶部，所以就可以直接在 foo.js 调用还没执行完毕的bar.js的 bar 方法")]),o._v(" "),n("p",[o._v("CommonJs 和 ES6 Module 的区别\n其实上面我们已经说到了一些区别")]),o._v(" "),n("p",[o._v("CommonJs导出的是变量的一份拷贝，ES6 Module导出的是变量的绑定（引用）\nCommonJs是单个值导出，ES6 Module可以导出多个\nCommonJs是动态语法可以写在判断里，ES6 Module静态语法只能写在顶层\nCommonJs的 this 是当前模块，ES6 Module的 this 是 undefined\n易混淆点\n模块语法与解构\nmodule语法与解构语法很容易混淆，例如：")]),o._v(" "),n("p",[o._v("import { a } from 'module'")]),o._v(" "),n("p",[o._v("const { a } = require('module')\n尽管看上去很像，但是不是同一个东西，这是两种完全不一样的语法与作用，ps:两个人撞衫了，穿一样的衣服你不能说这俩人就是同一个人\nmodule 的语法： 上面有写 import/export { a } / { a, b } / { a as c} FromClause\n解构 的语法：")]),o._v(" "),n("p",[o._v("let { a } = { a: 1 }\nlet { a = 2 } = { }\nlet { a: b } = { a: 1 }\nlet { a: b = 2, ...res } = { name:'a' }\nlet { a: b, obj: { name } } = { a: 1, obj: { name: '1' } }")]),o._v(" "),n("p",[o._v("function foo({a: []}) {}\n他们是差别非常大的两个东西，一个是模块导入导出，一个是获取对象的语法糖")]),o._v(" "),n("p",[o._v("导出语法与对象属性简写\n同样下面这段代码也容易混淆")]),o._v(" "),n("p",[o._v("let a = 1")]),o._v(" "),n("p",[o._v("export { a } // 导出语法\nexport default { a } // 属性简写 导出 { a: 1 } 对象")]),o._v(" "),n("p",[o._v("module.exports = { a } // 属性简写 导出 { a: 1 } 对象\nexport default 和 module.exports 是相似的")]),o._v(" "),n("p",[o._v("ES6 module 支持 CommonJs 情况\n先简单说一下各个环境的 ES6 module 支持 CommonJs 情况，后面单独说如何在不同环境中使用")]),o._v(" "),n("p",[o._v("因为 module.exports 很像 export default 所以 ES6模块 可以很方便兼容 CommonJs\n在ES6 module中使用CommonJs规范，根据各个环境，打包工具不同也是不一样的")]),o._v(" "),n("p",[o._v("我们现在大多使用的是 webpack 进行项目构建打包，因为现在前端开发环境都是在 Node 环境原因，而 npm 的包都是 CommonJs 规范的，所以 webpack 对ES6模块进行扩展 支持 CommonJs，并支持node的导入npm包的规范")]),o._v(" "),n("p",[o._v("如果你使用 rollup，想在ES Module中支持Commonjs规范就需要下载rollup-plugin-commonjs插件，想要导入node_modules下的包也需要rollup-plugin-node-resolve插件")]),o._v(" "),n("p",[o._v("如果你使用 node，可以在 .mjs 文件使用 ES6，也支持 CommonJs 查看 nodejs es-modules.md")]),o._v(" "),n("p",[o._v("在浏览器环境 不支持CommonJs")]),o._v(" "),n("p",[o._v("node 与 打包工具webpack，rollup的导入 CommonJs 差异")]),o._v(" "),n("p",[o._v("// module.js\nmodule.export.a = 1")]),o._v(" "),n("p",[o._v("// index.js webpack rollup\nimport * as a from './module'\nconsole.log(a) // { a: 1, default: { a:1 } }")]),o._v(" "),n("p",[o._v("// index.mjs node\nimport * as a from './module'\nconsole.log(a) // { default: { a:1 } }\nnode 只是把 module.exports 整体当做 export default\n打包工具除了把 module.export 整体当做 export default，还把 module.export 的每一项 又当做 export 输出，这样做是为了更加简洁\nimport defaultExport from './foo'， defaultExport.foo()\nimport { foo } from './foo'， foo()")]),o._v(" "),n("p",[o._v("使用 ES6 Module\n可以在 es6module example 仓库中获取代码在本地进行测试验证")]),o._v(" "),n("p",[o._v("浏览器中使用\n你需要起一个Web服务器来访问，双击本地运行 index.html 并不会执行 type=module 标签\n我们可以对 script 标签的 type 属性加上 module\n先定义两个模块")]),o._v(" "),n("p",[o._v("// index.js\nimport module from './module.js'\nconsole.log(module) // 123")]),o._v(" "),n("p",[o._v("// module.js\nexport default 123\n在html中内联调用")]),o._v(" "),n("p",[o._v("\x3c!-- index.html --\x3e <script type=\"module\"> import module from './module.js' console.log(module) // 123 <\/script>")]),o._v(" "),n("p",[o._v("在html中内联调用")]),o._v(" "),n("p",[o._v('\x3c!-- index.html --\x3e <script type="module" src="index.js"><\/script> // 控制台 123')]),o._v(" "),n("p",[o._v("浏览器导入路径规则\nhttps://example.com/apples.mjs\nhttp://example.com/apples.js\n//example.com/bananas\n./strawberries.mjs.cgi\n../lychees\n/limes.jsx\ndata:text/javascript,export default 'grapes';\nblob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f\n补充:")]),o._v(" "),n("p",[o._v("不加 后缀名 找不到具体的文件\n后端可以修改接口/getjs?name=module这一类的，不过后端要返回 Content-Type: application/javascript 确保返回的是js,因为浏览器是根据 MIME type 识别的\n因为 ES6 Module 在浏览器中兼容并不是很好，这里就不介绍浏览器支持情况了，我们一般不会直接在浏览器中使用")]),o._v(" "),n("p",[o._v("Nodejs中使用\nnodejs es-modules.md")]),o._v(" "),n("p",[o._v("在 Node v8.5.0 以上支持 ES Module，需要 .mjs扩展名")]),o._v(" "),n("p",[o._v("NOTE: DRAFT status does not mean ESM will be implemented in Node core. Instead that this is the standard, should Node core decide to implement ESM. At which time this draft would be moved to ACCEPTED.\n（上面链接可以知道 ES Module的状态是 DRAFT， 属于起草阶段）")]),o._v(" "),n("p",[o._v("// module.mjs\nexport default 123")]),o._v(" "),n("p",[o._v("// index.mjs\nimport module from './module.mjs'\nconsole.log(module) // 123\n我们需要执行 node --experimental-modules index.mjs 来启动\n会提示一个 ExperimentalWarning: The ESM module loader is experimental.该功能是实验性的（此提示不影响执行）\nES Module 中导入 CommonJs")]),o._v(" "),n("p",[o._v("// module.js\nmodule.exports.a = 123 // module.exports 就相当于 export default")]),o._v(" "),n("p",[o._v("// index.mjs\nimport module from './module.js'\nconsole.log(module) // { a: 123 }")]),o._v(" "),n("p",[o._v("import * as module from './module.js'\nconsole.log(module) // { get default: { a: 123 } }")]),o._v(" "),n("p",[o._v("import { default as module } from './module.js';\nconsole.log(module) // { a: 123 }")]),o._v(" "),n("p",[o._v("import module from 'module'; // 导入npm包 导入规则与 require 差不多\n导入路径规则与require差不多\n这里要注意 module 扩展名为 .js，.mjs专属于 es module，import form导入的文件后缀名只能是.mjs，在 .mjs中 module未定义， 所以调用 module.exports，exports 会报错")]),o._v(" "),n("p",[o._v("node中 CommonJs 导入 es module 只能使用 import() 动态导入/异步导入")]),o._v(" "),n("p",[o._v("// es.mjs\nlet foo = {name: 'foo'};\nexport default foo;")]),o._v(" "),n("p",[o._v("export let a = 1")]),o._v(" "),n("p",[o._v("// cjs\nimport('./es').then((res)=>{\nconsole.log(res) // { get default: {name: 'foo'}, a: 1 }\n});\nwebpack中使用\n从 webpack2 就默认支持 es module 了，并默认支持 CommonJs，支持导入 npm包， 这里 import 语法上面写太多 就不再写了")]),o._v(" "),n("p",[o._v("rollup中使用\nrollup 专注于 es module，可以将 es module 打包为主流的模块规范，注意这里与 webpack 的区别，我们可以在 webpack 的 js 中使用 Commonjs 语法， 但是 rollup 不支持，rollup需要 plugin 支持，包括加载 node_modules 下的包 form 'react' 也需要 plugin 支持")]),o._v(" "),n("p",[o._v("可以看到 es module 在浏览器与node中兼容性差与实验功能的\n我们大多时候在 打包工具 中使用")]),o._v(" "),n("p",[o._v("Tree-shaking\n在最后我们说一下经常跟 es module 一起出现的一个名词 Tree-shaking\nTree-shaking 我们先直译一下 树木摇晃 就是 摇晃树木把上面枯死的树叶晃下来，在代码中就是把没有用到的代码删除\nTree-shaking 最早由 rollup 提出，之后 webpack 2 也开始支持\n这都是基于 es module 模块特性的静态分析")]),o._v(" "),n("p",[o._v("rollup\n下面代码使用 rollup 进行打包：")]),o._v(" "),n("p",[o._v("// module.js\nexport let foo = 'foo'\nexport let bar = 'bar'")]),o._v(" "),n("p",[o._v("// index.js\nimport { foo } from './module'\nconsole.log(foo) // foo\n在线运行 我们可以修改例子与导出多种规范")]),o._v(" "),n("p",[o._v("打包结果：")]),o._v(" "),n("p",[o._v("let foo = 'foo';")]),o._v(" "),n("p",[o._v("console.log(foo); // foo\n可以看到 rollup 打包结果非常的简洁，并去掉了没有用到的 bar\n是否支持对导入 CommonJs 的规范进行 Tree-shaking：")]),o._v(" "),n("p",[o._v("// index.js\nimport { a } from './module'\nconsole.log(a) // 1")]),o._v(" "),n("p",[o._v("// module.js\nmodule.exports.a = 1\nmodule.exports.b = 2\n打包为 es module")]),o._v(" "),n("p",[o._v("var a_1 = 2;")]),o._v(" "),n("p",[o._v("console.log(a_1);\n可以看到去掉了未使用的 b")]),o._v(" "),n("p",[o._v("webpack\n我们下面看看 webpack 的支持情况")]),o._v(" "),n("p",[o._v("// src/module.js\nexport function foo(){ return 'foo' }\nexport function bar(){ return 'bar' }")]),o._v(" "),n("p",[o._v("// src/index.js\nimport { foo } from './module'\nconsole.log(foo())\n执行 npx webpack -p（我们使用webpack 4，0配置，-p开启生成模式 自动压缩）\n打包后我们在打包文件搜索 bar 没有搜到，bar被删除\n我们将上面例子修改一下：")]),o._v(" "),n("p",[o._v("// src/module.js\nmodule.exports.foo = function (){ return 'foo' }\nmodule.exports.bar = function (){ return 'bar' }")]),o._v(" "),n("p",[o._v("// src/index.js\nimport { foo } from './module'\nconsole.log(foo())\n打包后搜索 bar 发现bar存在，webpack 并不支持对CommonJs 进行 Tree-shaking")]),o._v(" "),n("p",[o._v("pkg.module\nwebpack 不支持 Commonjs Tree-shaking，但现在npm的包都是CommonJs规范的，这该怎么办呢 ？如果我发了一个新包是 es module 规范， 但是如果代码运行在 node 环境，没有经过打包 就会报错")]),o._v(" "),n("p",[o._v("有一种按需加载的方案")]),o._v(" "),n("p",[o._v("全路径导入，导入具体的文件：")]),o._v(" "),n("p",[o._v("// src/index.js\nimport remove from 'lodash/remove'\nimport add from 'lodash/add'")]),o._v(" "),n("p",[o._v("console.log(remove(), add())\n使用一个还好，如果用多个的话会有很多 import 语句\n还可以使用插件如 babel-plugin-lodash, & lodash-webpack-plugin")]),o._v(" "),n("p",[o._v("但我们不能发一个库就自己写插件")]),o._v(" "),n("p",[o._v("这时就提出了在 package.json 加一个 module 的字段来指向 es module规范的文件，main -> CommonJs，那么module - es module pkg.module")]),o._v(" "),n("p",[o._v("webpack 与 rollup 都支持 pkg.module")]),o._v(" "),n("p",[o._v("加了 module 字段 webpack 就可以识别我们的 es module，但是还有一个问题就是 babel")]),o._v(" "),n("p",[o._v("我们一般使用 babel 都会排除 node_modules，所以我们这个 pkg.module 只是的 es6 module必须是编译之后的 es5 代码，因为 babel 不会帮我们编译，我们的包就必须是 拥有 es6 module 规范的 es5 代码")]),o._v(" "),n("p",[o._v('如果你使用了 presets-env 因为会把我们的代码转为 CommonJs 所以就要设置 "presets": [["env", {"modules":false}] 不将es module 转为 CommonJs')]),o._v(" "),n("p",[o._v("webpack 与 rollup 的区别\nwebpack 不支持导出 es6 module 规范，rollup 支持导出 es6 module\nwebpack 打包后代码很多冗余无法直接看，rollup 打包后的代码简洁，可读，像源码\nwebpack 可以进行代码分割，静态资源处理，HRM，rollup 专注于 es module，tree-shaking更加强大的，精简\n如果是开发应用可以使用 webpack，因为可以进行代码分割，静态资源，HRM，插件\n如果是开发类似 vue，react 等类库，rollup 更好一些，因为可以使你的代码精简，无冗余代码，执行更快,导出多种模块语法")]),o._v(" "),n("p",[o._v("结语\n本文章介绍了 Commonjs 和 ES6 Module，导入导出的语法规则，路径解析规则，两者的区别，容易混淆的地方，在不同环境的区别，在不同环境的使用，Tree-shaking，与 webpack，rollup 的区别\n希望您读完文章后，能对前端的模块化有更深的了解")]),o._v(" "),n("p",[o._v("参考链接\nECMAScript® 2015 Language Specification sec-imports/sec-exports\nMDN import\ngithub nodejs lib/module\ngithub nodejs node-eps/002-es-modules\nnodejs docs modules\nUnderstanding ECMAScript 6\nECMAScript 6 入门\nes6-modules-final\n来源：https://segmentfault.com/a/1190000017878394")])])},[],!1,null,null,null);e.default=p.exports}}]);