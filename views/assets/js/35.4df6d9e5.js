(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{168:function(n,e,s){"use strict";s.r(e);var t=s(0),a=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("div",{staticClass:"content"},[s("p",[n._v("同一个标识符的情况下，变量声明与函数声明都会提升；函数声明会覆盖变量声明，但不会覆盖变量赋值，即：如果声明变量的同时初始化或赋值那么变量优先级高于函数")]),n._v(" "),s("p",[n._v('函式表达式中函数的识别名是可以不需要有的，有名称的函数表达式，也就是所谓的"具名函数表达式"(Named function expressions，NFE)，这个函数的识别名，它的作用域是只能在函数的主体(FunctionBody)内部。原因当然它只是个原本就可有可无的"代理"函数名，真正的这函数识别名称是被赋值的那个变量识别名。')]),n._v(" "),s("p",[n._v('正常情况下，你只能在函数表述式中的主体中使用这个"代理函数名"，这也是符合标准的规定，如下面的例子:')]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('var f = function foo(){\n  return typeof foo; \n};\ntypeof foo; // "undefined"\nf(); // "function"\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])])])}],!1,null,null,null);e.default=a.exports}}]);