(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{453:function(a,t,s){"use strict";s.r(t);var r=s(56),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"浏览器下的垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器下的垃圾回收机制"}},[a._v("#")]),a._v(" 浏览器下的垃圾回收机制")]),a._v(" "),s("p",[a._v("由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。而buffer不存在内存当中，它存储在硬盘，所以它不会被gc，但是它归gc调度。")]),a._v(" "),s("p",[a._v("JavaScript 使用垃圾回收机制来自动管理内存。")]),a._v(" "),s("p",[a._v("现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数")]),a._v(" "),s("h2",{attrs:{id:"标记清除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[a._v("#")]),a._v(" 标记清除")]),a._v(" "),s("p",[a._v('现代浏览器大多数采用这种方式：当变量进入环境时，将变量标记"进入环境"，当变量离开环境时，标记为：“离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。')]),a._v(" "),s("h2",{attrs:{id:"引用计数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[a._v("#")]),a._v(" 引用计数")]),a._v(" "),s("p",[a._v("引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1。当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。")]),a._v(" "),s("p",[a._v("因为存在循环引用的情况会导致内存无法释放，需要手动值为 null，因此大多数的浏览器已经放弃这种回收方式。")]),a._v(" "),s("h2",{attrs:{id:"什么时候触发垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么时候触发垃圾回收"}},[a._v("#")]),a._v(" 什么时候触发垃圾回收")]),a._v(" "),s("p",[a._v("一般浏览器会自动触发 GC，我们不用太过关注。但是和其他语言一样，当触发 GC 的时候，浏览器就会停止工作。如果频繁触发 GC 页面就会发生抖动现象。")]),a._v(" "),s("p",[a._v("一般的 GC 耗时在 100ms 左右，对于一般的程序来说够了。但是对于一些流畅度要求高的程序来说就很麻烦，这就需要新引擎需要优化的地方。")]),a._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"http://blog.colastar.club/static/images/何时启动gc.png"}},[s("img",{attrs:{src:"http://blog.colastar.club/static/images/%E4%BD%95%E6%97%B6%E5%90%AF%E5%8A%A8gc.png",alt:""}})])]),a._v(" "),s("h1",{attrs:{id:"chrome-的-gc-优化-v8-下的垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chrome-的-gc-优化-v8-下的垃圾回收机制"}},[a._v("#")]),a._v(" chrome 的 GC 优化（V8 下的垃圾回收机制）")]),a._v(" "),s("blockquote",[s("p",[a._v("V8 引擎的垃圾回收策略主要基于分代垃圾回收机制,将整个堆内存分为新生代内存和老龄代内存，所有的内存分配操作发生在新生代")])]),a._v(" "),s("h2",{attrs:{id:"新生代算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新生代算法"}},[a._v("#")]),a._v(" 新生代算法")]),a._v(" "),s("p",[a._v("新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。")]),a._v(" "),s("p",[a._v("在新生代空间中，内存空间分为两部分，每一个空间称为semispace。分别为 From 空间（使用）和 To 空间(闲置)。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了，所以所有的内存分配操作发生在 From 空间。而当再次进行回收，会发现被回收过直接晋升， 或者发现To空间已经使用了超过25%。")]),a._v(" "),s("p",[s("strong",[a._v("缺点")]),a._v("：是只能使 用堆内存的一半，这是一个典型的空间换时间的办法，但 是新生代声明周期较短，恰恰就适合这个算法。\n"),s("a",{attrs:{"data-fancybox":"",title:"",href:"http://blog.colastar.club/static/images/gc新生代.png"}},[s("img",{attrs:{src:"http://blog.colastar.club/static/images/gc%E6%96%B0%E7%94%9F%E4%BB%A3.png",alt:""}})])]),a._v(" "),s("h2",{attrs:{id:"老生代算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#老生代算法"}},[a._v("#")]),a._v(" 老生代算法")]),a._v(" "),s("p",[a._v("老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法(Mark-Sweep)和标记合并算法(Mark-compact)。")]),a._v(" "),s("p",[a._v("在讲算法前，先来说下什么情况下对象会出现在老生代空间中：")]),a._v(" "),s("ul",[s("li",[a._v("新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。")]),a._v(" "),s("li",[a._v("To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。")])]),a._v(" "),s("p",[a._v("老生代中的空间很复杂，有如下几个空间")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("enum AllocationSpace {\n  // TODO(v8:7464): Actually map this space's memory as read-only.\n  RO_SPACE,    // 不变的对象空间\n  NEW_SPACE,   // 新生代用于 GC 复制算法的空间\n  OLD_SPACE,   // 老生代常驻对象空间\n  CODE_SPACE,  // 老生代代码对象空间\n  MAP_SPACE,   // 老生代 map 对象\n  LO_SPACE,    // 老生代大空间对象\n  NEW_LO_SPACE,  // 新生代大空间对象\n\n  FIRST_SPACE = RO_SPACE,\n  LAST_SPACE = NEW_LO_SPACE,\n  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,\n  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE\n};\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br")])]),s("p",[a._v("在老生代中，以下情况会先启动标记清除算法：")]),a._v(" "),s("ul",[s("li",[a._v("某一个空间没有分块的时候")]),a._v(" "),s("li",[a._v("空间中被对象超过一定限制")]),a._v(" "),s("li",[a._v("空间不能保证新生代中的对象移动到老生代中")])]),a._v(" "),s("p",[a._v("在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 "),s("a",{attrs:{href:"https://v8.dev/blog/concurrent-marking",target:"_blank",rel:"noopener noreferrer"}},[a._v("该博客"),s("OutboundLink")],1),a._v(" 详细阅读。")]),a._v(" "),s("p",[a._v("清除算法完成之后会使内存空间出现不连续的状态，这种内存碎片会对后续的内存分配造成问题。因此在内存空间不足的时候采用标记合并算法，将活着的对象移动到内存的一端，完成之后清除另外一端的对象,当CPU空间不足的时候会非常的高效。 V8后续还引入了延迟处理，增量处理，并计划引入 并行标记处理。\n"),s("a",{attrs:{"data-fancybox":"",title:"",href:"http://blog.colastar.club/static/images/gc老生代.png"}},[s("img",{attrs:{src:"http://blog.colastar.club/static/images/gc%E8%80%81%E7%94%9F%E4%BB%A3.png",alt:""}})])]),a._v(" "),s("ul",[s("li",[a._v("新生代的 GC 触发要比老龄代的频繁")]),a._v(" "),s("li",[a._v("一般浏览器要求最高 60fps，算下来每帧 16.6ms。Chrome 为了缩短 GC 时间，它尝试将工作分摊到每个空闲时间。它将检查每个帧时间（16.6 ms）的剩余时间，并尝试为 GC 做一些工作\n"),s("a",{attrs:{"data-fancybox":"",title:"",href:"http://blog.colastar.club/static/images/gc1.png"}},[s("img",{attrs:{src:"http://blog.colastar.club/static/images/gc1.png",alt:""}})]),a._v(" "),s("a",{attrs:{"data-fancybox":"",title:"",href:"http://blog.colastar.club/static/images/gc优化.png"}},[s("img",{attrs:{src:"http://blog.colastar.club/static/images/gc%E4%BC%98%E5%8C%96.png",alt:""}})])])]),a._v(" "),s("p",[a._v("⚠️一句话表示:小孩子尽管玩，到处丢东西大人收。")]),a._v(" "),s("p",[a._v("注意点⚠️")]),a._v(" "),s("ul",[s("li",[a._v("Node使用JavaScript在服务端操作大内存对象受到了一定的限制(堆 区)，64位系统下约为1.4GB，32位操作系统下是0.7G.栈区新生代 64位是32M 32位是16M")]),a._v(" "),s("li",[s("strong",[a._v("怎么监控内存，查看是否gc")]),a._v("：可以通过内存快照查看")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Process.memoryUsage\nrss :所有内存使用包括堆区和栈区\nheaptTotal:堆区占用内存heapUsed:\n已使用到的堆部分external:\nV8引擎C++对象占用(GC动态变化)\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"http://blog.colastar.club/static/images/gc空间.png"}},[s("img",{attrs:{src:"http://blog.colastar.club/static/images/gc%E7%A9%BA%E9%97%B4.png",alt:""}})])])])}),[],!1,null,null,null);t.default=e.exports}}]);