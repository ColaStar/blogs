<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>个人博客</title>
    <meta name="description" content="来了老弟">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    
    <link rel="preload" href="/blogs/views/assets/css/0.styles.c95c3c00.css" as="style"><link rel="preload" href="/blogs/views/assets/js/app.50f9e9cf.js" as="script"><link rel="preload" href="/blogs/views/assets/js/2.5cbcc688.js" as="script"><link rel="preload" href="/blogs/views/assets/js/41.6f3e6dde.js" as="script"><link rel="prefetch" href="/blogs/views/assets/js/10.1a9232ef.js"><link rel="prefetch" href="/blogs/views/assets/js/11.10eef69f.js"><link rel="prefetch" href="/blogs/views/assets/js/12.9b3f5388.js"><link rel="prefetch" href="/blogs/views/assets/js/13.9bd1a6c0.js"><link rel="prefetch" href="/blogs/views/assets/js/14.291fc160.js"><link rel="prefetch" href="/blogs/views/assets/js/15.f0b3b166.js"><link rel="prefetch" href="/blogs/views/assets/js/16.46bec8b1.js"><link rel="prefetch" href="/blogs/views/assets/js/17.cbc33274.js"><link rel="prefetch" href="/blogs/views/assets/js/18.5b2ddd39.js"><link rel="prefetch" href="/blogs/views/assets/js/19.a87a73de.js"><link rel="prefetch" href="/blogs/views/assets/js/20.05f6e3b3.js"><link rel="prefetch" href="/blogs/views/assets/js/21.e02c7441.js"><link rel="prefetch" href="/blogs/views/assets/js/22.df450d3c.js"><link rel="prefetch" href="/blogs/views/assets/js/23.08388201.js"><link rel="prefetch" href="/blogs/views/assets/js/24.15e1fae4.js"><link rel="prefetch" href="/blogs/views/assets/js/25.41c309be.js"><link rel="prefetch" href="/blogs/views/assets/js/26.62269f72.js"><link rel="prefetch" href="/blogs/views/assets/js/27.2e99aa40.js"><link rel="prefetch" href="/blogs/views/assets/js/28.d56ce987.js"><link rel="prefetch" href="/blogs/views/assets/js/29.34830751.js"><link rel="prefetch" href="/blogs/views/assets/js/3.8935f0d5.js"><link rel="prefetch" href="/blogs/views/assets/js/30.5a4c4e26.js"><link rel="prefetch" href="/blogs/views/assets/js/31.4eda5766.js"><link rel="prefetch" href="/blogs/views/assets/js/32.9cd27e48.js"><link rel="prefetch" href="/blogs/views/assets/js/33.470f16d7.js"><link rel="prefetch" href="/blogs/views/assets/js/34.34432478.js"><link rel="prefetch" href="/blogs/views/assets/js/35.23445910.js"><link rel="prefetch" href="/blogs/views/assets/js/36.21f918eb.js"><link rel="prefetch" href="/blogs/views/assets/js/37.19d8a55c.js"><link rel="prefetch" href="/blogs/views/assets/js/38.97d17bea.js"><link rel="prefetch" href="/blogs/views/assets/js/39.7c857274.js"><link rel="prefetch" href="/blogs/views/assets/js/4.5d22d68b.js"><link rel="prefetch" href="/blogs/views/assets/js/40.7e2cf428.js"><link rel="prefetch" href="/blogs/views/assets/js/42.dcdc2239.js"><link rel="prefetch" href="/blogs/views/assets/js/43.8de2cf9b.js"><link rel="prefetch" href="/blogs/views/assets/js/44.24c0de2a.js"><link rel="prefetch" href="/blogs/views/assets/js/45.2d8c1405.js"><link rel="prefetch" href="/blogs/views/assets/js/46.66e89e18.js"><link rel="prefetch" href="/blogs/views/assets/js/47.71b01a7c.js"><link rel="prefetch" href="/blogs/views/assets/js/48.a2483236.js"><link rel="prefetch" href="/blogs/views/assets/js/49.e3b2b4ca.js"><link rel="prefetch" href="/blogs/views/assets/js/5.34d100e2.js"><link rel="prefetch" href="/blogs/views/assets/js/50.a904a5af.js"><link rel="prefetch" href="/blogs/views/assets/js/51.3a7ce26a.js"><link rel="prefetch" href="/blogs/views/assets/js/52.a5c7cbd7.js"><link rel="prefetch" href="/blogs/views/assets/js/53.6b5c7eed.js"><link rel="prefetch" href="/blogs/views/assets/js/54.385a964b.js"><link rel="prefetch" href="/blogs/views/assets/js/55.85112868.js"><link rel="prefetch" href="/blogs/views/assets/js/56.64cf9383.js"><link rel="prefetch" href="/blogs/views/assets/js/57.089a37eb.js"><link rel="prefetch" href="/blogs/views/assets/js/58.28e0f5aa.js"><link rel="prefetch" href="/blogs/views/assets/js/59.899842d0.js"><link rel="prefetch" href="/blogs/views/assets/js/6.356d53e2.js"><link rel="prefetch" href="/blogs/views/assets/js/7.9d5ba939.js"><link rel="prefetch" href="/blogs/views/assets/js/8.e2d49737.js"><link rel="prefetch" href="/blogs/views/assets/js/9.9ccf4e48.js">
    <link rel="stylesheet" href="/blogs/views/assets/css/0.styles.c95c3c00.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blogs/views/" class="home-link router-link-active"><!----> <span class="site-name">个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端资料</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>css</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/css-3d/css-3d.html" class="nav-link">css3D</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/css-core/css-core.html" class="nav-link">css3开发常备核心技能</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/css-core/css-layer.html" class="nav-link">CSS分层理论与面向对象</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/css-math/css-math.html" class="nav-link">CSS与数学</a></li></ul></li><li class="dropdown-item"><h4>HTML</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/html-senior/html-senior.html" class="nav-link">你不知道的HTML</a></li></ul></li><li class="dropdown-item"><h4>JavaScript语言新发展</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/JavaScript语言新发展【深度实践课】/ES6 在企业中的应用.html" class="nav-link">ES6 在企业中的应用</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/JavaScript语言新发展【深度实践课】/javascript与QA工程师.html" class="nav-link">javascript与QA工程师</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/JavaScript语言新发展【深度实践课】/TypeScript 前世今生.html" class="nav-link">TypeScript 前世今生</a></li></ul></li><li class="dropdown-item"><h4>JavaScript</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/JQuery/Jquery.html" class="nav-link">Jquery</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/bind_call_apply.html" class="nav-link">bind_call_apply</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/es6.html" class="nav-link">ES6</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/js-core.html" class="nav-link">js核心</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/scope.html" class="nav-link">作用域</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/this.html" class="nav-link">This</a></li></ul></li><li class="dropdown-item"><h4>Linux</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/linux/linux.html" class="nav-link">Linux</a></li></ul></li><li class="dropdown-item"><h4>Linux</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/linux/linux.html" class="nav-link">Linux</a></li></ul></li><li class="dropdown-item"><h4>MySQL &amp; PHP</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/php&amp;mysql/php&amp;mysql.html" class="nav-link">MySQL &amp; PHP</a></li></ul></li><li class="dropdown-item"><h4>读博客有感</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/bind的模拟实现.html" class="nav-link">bind的模拟实现</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/call和apply的模拟实现.html" class="nav-link">call和apply的模拟实现</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/new的模拟实现.html" class="nav-link">new的模拟实现</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/作用域链.html" class="nav-link">作用域链</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/原型与原型链.html" class="nav-link">原型与原型链</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/变量对象.html" class="nav-link">变量对象</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/执行上下文栈.html" class="nav-link">执行上下文栈</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/词法作用域与动态作用域.html" class="nav-link">词法作用域与动态作用域</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/闭包.html" class="nav-link">闭包</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/闭包与GC.html" class="nav-link">闭包与GC</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blogs/views/javascript-QA/index.html" class="nav-link">javascript与测试工程师</a></div><div class="nav-item"><a href="/blogs/views/no.2/http.html" class="nav-link">HTTP</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">编程思想</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>元编程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.1/元编程/" class="nav-link">元编程</a></li></ul></li><li class="dropdown-item"><h4>函数式编程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.1/函数式编程/" class="nav-link">函数式编程</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">node</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>node</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/node/node/node.html" class="nav-link">node</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/node/fs.html" class="nav-link">文件模块</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/node/nodemon.html" class="nav-link">node热启动</a></li></ul></li><li class="dropdown-item"><h4>Express</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/node/express/express.html" class="nav-link">express</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/express/middleware.html" class="nav-link">中间件</a></li></ul></li><li class="dropdown-item"><h4>Koa</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/node/koa/koa.html" class="nav-link">koa</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/koa/koa_router.html" class="nav-link">koa路由</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/koa/koa-generator.html" class="nav-link">koa应用生成器</a></li></ul></li><li class="dropdown-item"><!----> <a href="/blogs/views/node/npm/npm-scripts.html" class="nav-link">npm-scripts</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端资料</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>css</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/css-3d/css-3d.html" class="nav-link">css3D</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/css-core/css-core.html" class="nav-link">css3开发常备核心技能</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/css-core/css-layer.html" class="nav-link">CSS分层理论与面向对象</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/css-math/css-math.html" class="nav-link">CSS与数学</a></li></ul></li><li class="dropdown-item"><h4>HTML</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/html-senior/html-senior.html" class="nav-link">你不知道的HTML</a></li></ul></li><li class="dropdown-item"><h4>JavaScript语言新发展</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/JavaScript语言新发展【深度实践课】/ES6 在企业中的应用.html" class="nav-link">ES6 在企业中的应用</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/JavaScript语言新发展【深度实践课】/javascript与QA工程师.html" class="nav-link">javascript与QA工程师</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/JavaScript语言新发展【深度实践课】/TypeScript 前世今生.html" class="nav-link">TypeScript 前世今生</a></li></ul></li><li class="dropdown-item"><h4>JavaScript</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/JQuery/Jquery.html" class="nav-link">Jquery</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/bind_call_apply.html" class="nav-link">bind_call_apply</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/es6.html" class="nav-link">ES6</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/js-core.html" class="nav-link">js核心</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/scope.html" class="nav-link">作用域</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/js/this.html" class="nav-link">This</a></li></ul></li><li class="dropdown-item"><h4>Linux</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/linux/linux.html" class="nav-link">Linux</a></li></ul></li><li class="dropdown-item"><h4>Linux</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/linux/linux.html" class="nav-link">Linux</a></li></ul></li><li class="dropdown-item"><h4>MySQL &amp; PHP</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/php&amp;mysql/php&amp;mysql.html" class="nav-link">MySQL &amp; PHP</a></li></ul></li><li class="dropdown-item"><h4>读博客有感</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/bind的模拟实现.html" class="nav-link">bind的模拟实现</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/call和apply的模拟实现.html" class="nav-link">call和apply的模拟实现</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/new的模拟实现.html" class="nav-link">new的模拟实现</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/作用域链.html" class="nav-link">作用域链</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/原型与原型链.html" class="nav-link">原型与原型链</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/变量对象.html" class="nav-link">变量对象</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/执行上下文栈.html" class="nav-link">执行上下文栈</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/词法作用域与动态作用域.html" class="nav-link">词法作用域与动态作用域</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/闭包.html" class="nav-link">闭包</a></li><li class="dropdown-subitem"><a href="/blogs/views/no.0/读博客有感/闭包与GC.html" class="nav-link">闭包与GC</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blogs/views/javascript-QA/index.html" class="nav-link">javascript与测试工程师</a></div><div class="nav-item"><a href="/blogs/views/no.2/http.html" class="nav-link">HTTP</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">编程思想</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>元编程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.1/元编程/" class="nav-link">元编程</a></li></ul></li><li class="dropdown-item"><h4>函数式编程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/no.1/函数式编程/" class="nav-link">函数式编程</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">node</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>node</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/node/node/node.html" class="nav-link">node</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/node/fs.html" class="nav-link">文件模块</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/node/nodemon.html" class="nav-link">node热启动</a></li></ul></li><li class="dropdown-item"><h4>Express</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/node/express/express.html" class="nav-link">express</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/express/middleware.html" class="nav-link">中间件</a></li></ul></li><li class="dropdown-item"><h4>Koa</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/views/node/koa/koa.html" class="nav-link">koa</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/koa/koa_router.html" class="nav-link">koa路由</a></li><li class="dropdown-subitem"><a href="/blogs/views/node/koa/koa-generator.html" class="nav-link">koa应用生成器</a></li></ul></li><li class="dropdown-item"><!----> <a href="/blogs/views/node/npm/npm-scripts.html" class="nav-link">npm-scripts</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>深入 CommonJs 与 ES6 Module
目前主流的模块规范</p> <p>UMD
CommonJs
es6 module
umd 模块（通用模块）</p> <p>(function (global, factory) {
typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' &amp;&amp; define.amd ? define(factory) :
(global.libName = factory());
}(this, (function () { 'use strict';})));
如果你在js文件头部看到这样的代码，那么这个文件使用的就是 UMD 规范
实际上就是 amd + commonjs + 全局变量 这三种风格的结合
这段代码就是对当前运行环境的判断，如果是 Node 环境 就是使用 CommonJs 规范， 如果不是就判断是否为 AMD 环境， 最后导出全局变量
有了 UMD 后我们的代码和同时运行在 Node 和 浏览器上
所以现在前端大多数的库最后打包都使用的是 UMD 规范</p> <p>CommonJs
Nodejs 环境所使用的模块系统就是基于CommonJs规范实现的，我们现在所说的CommonJs规范也大多是指Node的模块系统</p> <p>模块导出
关键字：module.exports exports</p> <p>// foo.js</p> <p>//一个一个 导出
module.exports.age = 1
module.exports.foo = function(){}
exports.a = 'hello'</p> <p>//整体导出
module.exports = { age: 1, a: 'hello', foo:function(){} }</p> <p>//整体导出不能用<code>exports</code> 用exports不能在导入的时候使用
exports = { age: 1, a: 'hello', foo:function(){} }
这里需要注意 exports 不能被赋值，可以理解为在模块开始前exports = module.exports， 因为赋值之后exports失去了 对module.exports的引用，成为了一个模块内的局部变量</p> <p>模块导入
关键字：require</p> <p>const foo = require('./foo.js')
console.log(foo.age) //1
模块导入规则：
假设以下目录为 src/app/index.js 的文件 调用 require()</p> <p>./moduleA 相对路径开头
在没有指定后缀名的情况下
先去寻找同级目录同级目录：src/app/</p> <p>src/app/moduleA 无后缀名文件 按照javascript解析
src/app/moduleA.js js文件 按照javascript解析
src/app/moduleA.json json文件 按照json解析
src/app/moduleA.node node文件 按照加载的编译插件模块dlopen
同级目录没有 moduleA 文件会去找同级的 moduleA目录：src/app/moduleA</p> <p>src/app/moduleA/package.json 判断该目录是否有package.json文件， 如果有 找到main字段定义的文件返回， 如果 main 字段指向文件不存在 或 main字段不存在 或 package.json文件不存在向下执行
src/app/moduleA/index.js
src/app/moduleA/index.json
src/app/moduleA/index.node
结束</p> <p>/module/moduleA 绝对路径开头
直接在/module/moduleA目录中寻找 规则同上</p> <p>react 没有路径开头
没有路径开头则视为导入一个包
会先判断moduleA是否是一个核心模块 如path，http，优先导入核心模块
不是核心模块 会从当前文件的同级目录的node_modules寻找</p> <p>/src/app/node_modules/ 寻找规则同上 以导入react为例 先 node_modules 下 react 文件 -&gt; react.js -&gt; react.json -&gt; react.node -&gt;react目录 -&gt; react package.json main -&gt; index.js -&gt; index.json -&gt; index.node 如果没找到 继续向父目录的node_modules中找
/src/node_modules/
/node_modules/
直到最后找不到 结束</p> <p>require wrapper
Node的模块 实际上可以理解为代码被包裹在一个函数包装器内
一个简单的require demo：</p> <p>function wrapper (script) {
return '(function (exports, require, module, __filename, __dirname) {' +
script +
'\n})'
}</p> <p>function require(id) {
var cachedModule = Module._cache[id];
if(cachedModule){
return cachedModule.exports;
}</p> <p>const module = { exports: {} }</p> <p>// 这里先将引用加入缓存 后面循环引用会说到
Module._cache[id] = module</p> <p>//当然不是eval这么简单
eval(wrapper('module.exports = &quot;123&quot;'))(module.exports, require, module, 'filename', 'dirname')</p> <p>return module.exports
}
也可以查看：node module 源码
从以上代码我们可以知道：</p> <p>模块只执行一次 之后调用获取的 module.exports 都是缓存哪怕这个 js 还没执行完毕（因为先加入缓存后执行模块）
模块导出就是return这个变量的其实跟a = b赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址
exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports， 所以对exports进行赋值会导致exports操作的不再是module.exports的引用
循环引用</p> <p>// a.js
module.exports.a = 1
var b = require('./b')
console.log(b)
module.exports.a = 2</p> <p>// b.js
module.exports.b = 11
var a = require('./a')
console.log(a)
module.exports.b = 22</p> <p>//main.js
var a = require('./a')
console.log(a)
运行此段代码结合上面的require demo，分析每一步过程：</p> <p>执行 node main.js -&gt; 第一行 require(a.js)，（node 执行也可以理解为调用了require方法，我们省略require(main.js)内容）
进入 require(a)方法： 判断缓存（无） -&gt; 初始化一个 module -&gt; 将 module 加入缓存 -&gt; 执行模块 a.js 内容，（需要注意 是先加入缓存， 后执行模块内容）
a.js： 第一行导出 a = 1 -&gt; 第二行 require(b.js)（a 只执行了第一行）
进入 require(b) 内 同 1 -&gt; 执行模块 b.js 内容
b.js： 第一行 b = 11 -&gt; 第二行 require(a.js)
require(a) 此时 a.js 是第二次调用 require -&gt; 判断缓存（有）-&gt; cachedModule.exports -&gt; 回到 b.js（因为js对象引用问题 此时的 cachedModule.exports = { a: 1 }）
b.js：第三行 输出 { a: 1 } -&gt; 第四行 修改 b = 22 -&gt; 执行完毕回到 a.js
a.js：第二行 require 完毕 获取到 b -&gt; 第三行 输出 { b: 22 } -&gt; 第四行 导出 a = 2 -&gt; 执行完毕回到 main.js
main.js：获取 a -&gt; 第二行 输出 { a: 2 } -&gt; 执行完毕
以上就是node的module模块解析和运行的大致规则</p> <p>es6 module
ES6 之前 javascript 一直没有属于自己的模块规范，所以社区制定了 CommonJs规范， Node 从 Commonjs 规范中借鉴了思想于是有了 Node 的 module，而 AMD 异步模块 也同样脱胎于 Commonjs 规范，之后有了运行在浏览器上的 require.js</p> <p>es6 module 基本语法：</p> <p>export</p> <p>export * from 'module'; //重定向导出 不包括 module内的default
export { name1, name2, ..., nameN } from 'module'; // 重定向命名导出
export { import1 as name1, import2 as name2, ..., nameN } from 'module'; // 重定向重命名导出</p> <p>export { name1, name2, …, nameN }; // 与之前声明的变量名绑定 命名导出
export { variable1 as name1, variable2 as name2, …, nameN }; // 重命名导出</p> <p>export let name1 = 'name1'; // 声明命名导出 或者 var, const，function， function*, class</p> <p>export default expression; // 默认导出
export default function () { ... } // 或者 function*, class
export default function name1() { ... } // 或者 function*, class
export { name1 as default, ... }; // 重命名为默认导出
export 规则</p> <p>export * from '' 或者 export {} from ''，重定向导出，重定向的命名并不能在本模块使用，只是搭建一个桥梁，例如：这个a并不能在本模块内使用
export {}， 与变量名绑定，命名导出
export Declaration，声明的同时，命名导出， Declaration就是： var, let, const, function, function*, class 这一类的声明语句
export default AssignmentExpression，默认导出， AssignmentExpression的 范围很广，可以大致理解 为除了声明Declaration（其实两者是有交叉的），a=2,i++,i/4,a===b,obj[name],name in obj,func(),new P(),[1,2,3],function(){}等等很多
import</p> <p>// 命名导出 module.js
let a = 1,b = 2
export { a, b }
export let c = 3</p> <p>// 命名导入 main.js
import { a, b, c } from 'module'; // a: 1  b: 2  c: 3
import { a as newA, b, c as newC } from 'module'; // newA: 1  b: 2  newC: 3</p> <p>// 默认导出 module.js
export default 1</p> <p>// 默认导入 main.js
import defaultExport from 'module'; // defaultExport: 1</p> <p>// 混合导出 module.js
let a = 1
export { a }
const b = 2
export { b }
export let c = 3
export default [1, 2, 3]</p> <p>// 混合导入 main.js
import defaultExport, { a, b, c as newC} from 'module'; //defaultExport: [1, 2, 3]  a: 1  b: 2  newC: 3
import defaultExport, * as name from 'module'; //defaultExport: [1, 2, 3]  name: { a: 1, b: 2, c: 3 }
import * as name from 'module'; // name: { a: 1, b: 2, c: 3, default: [1, 2, 3] }</p> <p>// module.js
Array.prototype.remove = function(){}</p> <p>//副作用 只运行一个模块
import 'module'; // 执行module 不导出值  多次调用module.js只运行一次</p> <p>//动态导入(异步导入)
var promise = import('module');
import 规则
import { } from 'module'， 导入module.js的命名导出
import defaultExport from 'module'， 导入module.js的默认导出
import * as name from 'module'， 将module.js的的所有导出合并为name的对象，key为导出的命名，默认导出的key为default
import 'module'，副作用，只是运行module，不为了导出内容例如 polyfill，多次调用次语句只能执行一次
import('module')，动态导入返回一个 Promise，TC39的stage-3阶段被提出 tc39 import
ES6 module 特点
ES6 module的语法是静态的
import 会自动提升到代码的顶层</p> <p>export 和 import 只能出现在代码的顶层，下面这段语法是错误的</p> <p>//if for while 等都无法使用
{
export let a = 1</p> <p>import defaultExport from 'module'
}</p> <p>true || export let a = 1
import 的导入名不能为字符串或在判断语句，下面代码是错误的</p> <p>import 'defaultExport' from 'module'</p> <p>let name = 'Export'
import 'default' + name from 'module'
静态的语法意味着可以在编译时确定导入和导出，更加快速的查找依赖，可以使用lint工具对模块依赖进行检查，可以对导入导出加上类型信息进行静态的类型检查</p> <p>ES6 module的导出是绑定的
使用 import 被导入的模块运行在严格模式下</p> <p>使用 import 被导入的变量是只读的，可以理解默认为 const 装饰，无法被赋值</p> <p>使用 import 被导入的变量是与原变量绑定/引用的，可以理解为 import 导入的变量无论是否为基本类型都是引用传递</p> <p>// js中 基础类型是值传递
let a = 1
let b = a
b = 2
console.log(a,b) //1 2</p> <p>// js中 引用类型是引用传递
let obj = {name:'obj'}
let obj2 = obj
obj2.name = 'obj2'
console.log(obj.name, obj2.name) // obj2  obj2</p> <p>// es6 module 中基本类型也按引用传递
// foo.js
export let a = 1
export function count(){
a++
}</p> <p>// main.js
import { a, count } from './foo'
console.log(a) //1
count()
console.log(a) //2
上面这段代码就是 CommonJs 导出变量 和 ES6 导出变量的区别</p> <p>es module 循环引用</p> <p>// bar.js
import { foo } from './foo'
console.log(foo);
export let bar = 'bar'</p> <p>// foo.js
import { bar } from './bar'
console.log(bar);
export let foo = 'foo'</p> <p>// main.js
import { bar } from './bar'
console.log(bar)
执行 main.js -&gt; 导入 bar.js
bar.js -&gt; 导入 foo.js
foo.js -&gt; 导入 bar.js -&gt; bar.js 已经执行过直接返回 -&gt; 输出 bar -&gt; bar is not defined， bar 未定义报错
我们可以使用function的方式解决：</p> <p>// bar.js
import { foo } from './foo'
console.log(foo());
export function bar(){
return 'bar'
}</p> <p>// foo.js
import { bar } from './bar'
console.log(bar());
export function foo(){
return 'foo'
}</p> <p>// main.js
import { bar } from './bar'
console.log(bar)
因为函数声明会提示到文件顶部，所以就可以直接在 foo.js 调用还没执行完毕的bar.js的 bar 方法</p> <p>CommonJs 和 ES6 Module 的区别
其实上面我们已经说到了一些区别</p> <p>CommonJs导出的是变量的一份拷贝，ES6 Module导出的是变量的绑定（引用）
CommonJs是单个值导出，ES6 Module可以导出多个
CommonJs是动态语法可以写在判断里，ES6 Module静态语法只能写在顶层
CommonJs的 this 是当前模块，ES6 Module的 this 是 undefined
易混淆点
模块语法与解构
module语法与解构语法很容易混淆，例如：</p> <p>import { a } from 'module'</p> <p>const { a } = require('module')
尽管看上去很像，但是不是同一个东西，这是两种完全不一样的语法与作用，ps:两个人撞衫了，穿一样的衣服你不能说这俩人就是同一个人
module 的语法： 上面有写 import/export { a } / { a, b } / { a as c} FromClause
解构 的语法：</p> <p>let { a } = { a: 1 }
let { a = 2 } = { }
let { a: b } = { a: 1 }
let { a: b = 2, ...res } = { name:'a' }
let { a: b, obj: { name } } = { a: 1, obj: { name: '1' } }</p> <p>function foo({a: []}) {}
他们是差别非常大的两个东西，一个是模块导入导出，一个是获取对象的语法糖</p> <p>导出语法与对象属性简写
同样下面这段代码也容易混淆</p> <p>let a = 1</p> <p>export { a } // 导出语法
export default { a } // 属性简写 导出 { a: 1 } 对象</p> <p>module.exports = { a } // 属性简写 导出 { a: 1 } 对象
export default 和 module.exports 是相似的</p> <p>ES6 module 支持 CommonJs 情况
先简单说一下各个环境的 ES6 module 支持 CommonJs 情况，后面单独说如何在不同环境中使用</p> <p>因为 module.exports 很像 export default 所以 ES6模块 可以很方便兼容 CommonJs
在ES6 module中使用CommonJs规范，根据各个环境，打包工具不同也是不一样的</p> <p>我们现在大多使用的是 webpack 进行项目构建打包，因为现在前端开发环境都是在 Node 环境原因，而 npm 的包都是 CommonJs 规范的，所以 webpack 对ES6模块进行扩展 支持 CommonJs，并支持node的导入npm包的规范</p> <p>如果你使用 rollup，想在ES Module中支持Commonjs规范就需要下载rollup-plugin-commonjs插件，想要导入node_modules下的包也需要rollup-plugin-node-resolve插件</p> <p>如果你使用 node，可以在 .mjs 文件使用 ES6，也支持 CommonJs 查看 nodejs es-modules.md</p> <p>在浏览器环境 不支持CommonJs</p> <p>node 与 打包工具webpack，rollup的导入 CommonJs 差异</p> <p>// module.js
module.export.a = 1</p> <p>// index.js webpack rollup
import * as a from './module'
console.log(a) // { a: 1, default: { a:1 } }</p> <p>// index.mjs node
import * as a from './module'
console.log(a) // { default: { a:1 } }
node 只是把 module.exports 整体当做 export default
打包工具除了把 module.export 整体当做 export default，还把 module.export 的每一项 又当做 export 输出，这样做是为了更加简洁
import defaultExport from './foo'， defaultExport.foo()
import { foo } from './foo'， foo()</p> <p>使用 ES6 Module
可以在 es6module example 仓库中获取代码在本地进行测试验证</p> <p>浏览器中使用
你需要起一个Web服务器来访问，双击本地运行 index.html 并不会执行 type=module 标签
我们可以对 script 标签的 type 属性加上 module
先定义两个模块</p> <p>// index.js
import module from './module.js'
console.log(module) // 123</p> <p>// module.js
export default 123
在html中内联调用</p> <p>&lt;!-- index.html --&gt; &lt;script type=&quot;module&quot;&gt; import module from './module.js' console.log(module) // 123 &lt;/script&gt;</p> <p>在html中内联调用</p> <p>&lt;!-- index.html --&gt; &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; // 控制台 123</p> <p>浏览器导入路径规则
https://example.com/apples.mjs
http://example.com/apples.js
//example.com/bananas
./strawberries.mjs.cgi
../lychees
/limes.jsx
data:text/javascript,export default 'grapes';
blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f
补充:</p> <p>不加 后缀名 找不到具体的文件
后端可以修改接口/getjs?name=module这一类的，不过后端要返回 Content-Type: application/javascript 确保返回的是js,因为浏览器是根据 MIME type 识别的
因为 ES6 Module 在浏览器中兼容并不是很好，这里就不介绍浏览器支持情况了，我们一般不会直接在浏览器中使用</p> <p>Nodejs中使用
nodejs es-modules.md</p> <p>在 Node v8.5.0 以上支持 ES Module，需要 .mjs扩展名</p> <p>NOTE: DRAFT status does not mean ESM will be implemented in Node core. Instead that this is the standard, should Node core decide to implement ESM. At which time this draft would be moved to ACCEPTED.
（上面链接可以知道 ES Module的状态是 DRAFT， 属于起草阶段）</p> <p>// module.mjs
export default 123</p> <p>// index.mjs
import module from './module.mjs'
console.log(module) // 123
我们需要执行 node --experimental-modules index.mjs 来启动
会提示一个 ExperimentalWarning: The ESM module loader is experimental.该功能是实验性的（此提示不影响执行）
ES Module 中导入 CommonJs</p> <p>// module.js
module.exports.a = 123 // module.exports 就相当于 export default</p> <p>// index.mjs
import module from './module.js'
console.log(module) // { a: 123 }</p> <p>import * as module from './module.js'
console.log(module) // { get default: { a: 123 } }</p> <p>import { default as module } from './module.js';
console.log(module) // { a: 123 }</p> <p>import module from 'module'; // 导入npm包 导入规则与 require 差不多
导入路径规则与require差不多
这里要注意 module 扩展名为 .js，.mjs专属于 es module，import form导入的文件后缀名只能是.mjs，在 .mjs中 module未定义， 所以调用 module.exports，exports 会报错</p> <p>node中 CommonJs 导入 es module 只能使用 import() 动态导入/异步导入</p> <p>// es.mjs
let foo = {name: 'foo'};
export default foo;</p> <p>export let a = 1</p> <p>// cjs
import('./es').then((res)=&gt;{
console.log(res) // { get default: {name: 'foo'}, a: 1 }
});
webpack中使用
从 webpack2 就默认支持 es module 了，并默认支持 CommonJs，支持导入 npm包， 这里 import 语法上面写太多 就不再写了</p> <p>rollup中使用
rollup 专注于 es module，可以将 es module 打包为主流的模块规范，注意这里与 webpack 的区别，我们可以在 webpack 的 js 中使用 Commonjs 语法， 但是 rollup 不支持，rollup需要 plugin 支持，包括加载 node_modules 下的包 form 'react' 也需要 plugin 支持</p> <p>可以看到 es module 在浏览器与node中兼容性差与实验功能的
我们大多时候在 打包工具 中使用</p> <p>Tree-shaking
在最后我们说一下经常跟 es module 一起出现的一个名词 Tree-shaking
Tree-shaking 我们先直译一下 树木摇晃 就是 摇晃树木把上面枯死的树叶晃下来，在代码中就是把没有用到的代码删除
Tree-shaking 最早由 rollup 提出，之后 webpack 2 也开始支持
这都是基于 es module 模块特性的静态分析</p> <p>rollup
下面代码使用 rollup 进行打包：</p> <p>// module.js
export let foo = 'foo'
export let bar = 'bar'</p> <p>// index.js
import { foo } from './module'
console.log(foo) // foo
在线运行 我们可以修改例子与导出多种规范</p> <p>打包结果：</p> <p>let foo = 'foo';</p> <p>console.log(foo); // foo
可以看到 rollup 打包结果非常的简洁，并去掉了没有用到的 bar
是否支持对导入 CommonJs 的规范进行 Tree-shaking：</p> <p>// index.js
import { a } from './module'
console.log(a) // 1</p> <p>// module.js
module.exports.a = 1
module.exports.b = 2
打包为 es module</p> <p>var a_1 = 2;</p> <p>console.log(a_1);
可以看到去掉了未使用的 b</p> <p>webpack
我们下面看看 webpack 的支持情况</p> <p>// src/module.js
export function foo(){ return 'foo' }
export function bar(){ return 'bar' }</p> <p>// src/index.js
import { foo } from './module'
console.log(foo())
执行 npx webpack -p（我们使用webpack 4，0配置，-p开启生成模式 自动压缩）
打包后我们在打包文件搜索 bar 没有搜到，bar被删除
我们将上面例子修改一下：</p> <p>// src/module.js
module.exports.foo = function (){ return 'foo' }
module.exports.bar = function (){ return 'bar' }</p> <p>// src/index.js
import { foo } from './module'
console.log(foo())
打包后搜索 bar 发现bar存在，webpack 并不支持对CommonJs 进行 Tree-shaking</p> <p>pkg.module
webpack 不支持 Commonjs Tree-shaking，但现在npm的包都是CommonJs规范的，这该怎么办呢 ？如果我发了一个新包是 es module 规范， 但是如果代码运行在 node 环境，没有经过打包 就会报错</p> <p>有一种按需加载的方案</p> <p>全路径导入，导入具体的文件：</p> <p>// src/index.js
import remove from 'lodash/remove'
import add from 'lodash/add'</p> <p>console.log(remove(), add())
使用一个还好，如果用多个的话会有很多 import 语句
还可以使用插件如 babel-plugin-lodash, &amp; lodash-webpack-plugin</p> <p>但我们不能发一个库就自己写插件</p> <p>这时就提出了在 package.json 加一个 module 的字段来指向 es module规范的文件，main -&gt; CommonJs，那么module - es module pkg.module</p> <p>webpack 与 rollup 都支持 pkg.module</p> <p>加了 module 字段 webpack 就可以识别我们的 es module，但是还有一个问题就是 babel</p> <p>我们一般使用 babel 都会排除 node_modules，所以我们这个 pkg.module 只是的 es6 module必须是编译之后的 es5 代码，因为 babel 不会帮我们编译，我们的包就必须是 拥有 es6 module 规范的 es5 代码</p> <p>如果你使用了 presets-env 因为会把我们的代码转为 CommonJs 所以就要设置 &quot;presets&quot;: [[&quot;env&quot;, {&quot;modules&quot;:false}] 不将es module 转为 CommonJs</p> <p>webpack 与 rollup 的区别
webpack 不支持导出 es6 module 规范，rollup 支持导出 es6 module
webpack 打包后代码很多冗余无法直接看，rollup 打包后的代码简洁，可读，像源码
webpack 可以进行代码分割，静态资源处理，HRM，rollup 专注于 es module，tree-shaking更加强大的，精简
如果是开发应用可以使用 webpack，因为可以进行代码分割，静态资源，HRM，插件
如果是开发类似 vue，react 等类库，rollup 更好一些，因为可以使你的代码精简，无冗余代码，执行更快,导出多种模块语法</p> <p>结语
本文章介绍了 Commonjs 和 ES6 Module，导入导出的语法规则，路径解析规则，两者的区别，容易混淆的地方，在不同环境的区别，在不同环境的使用，Tree-shaking，与 webpack，rollup 的区别
希望您读完文章后，能对前端的模块化有更深的了解</p> <p>参考链接
ECMAScript® 2015 Language Specification sec-imports/sec-exports
MDN import
github nodejs lib/module
github nodejs node-eps/002-es-modules
nodejs docs modules
Understanding ECMAScript 6
ECMAScript 6 入门
es6-modules-final
来源：https://segmentfault.com/a/1190000017878394</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">6/26/2019, 2:07:26 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blogs/views/assets/js/app.50f9e9cf.js" defer></script><script src="/blogs/views/assets/js/2.5cbcc688.js" defer></script><script src="/blogs/views/assets/js/41.6f3e6dde.js" defer></script>
  </body>
</html>
