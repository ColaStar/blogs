# 数据结构与算法

数据结构和算法是程序员的基本功，值得每一个程序员好好学习。数据结构表示计算机存储数据的方式，算法是完成某个特定任务的过程。

- 数据结构
- 算法
- 前端中的数据结构和算法
![](数据结构与算法体系图.png)
## 什么是数据结构
数据结构起源于程序设计，是用计算机来存储、组织数据的方式。数据结
构不是使我们学会编码，而是为我们提供一种编程的思想，具有更好的思路。

- 广义的说法:数据结构 = 数据存储 + 算法 
- 狭义的说法:数据结构 = 数据的存储;

### 数据结构中的概念

- 数据：统称
- 数据元素：相当于是视频文件
- 数据项：相当于视频的每一帧
- 数据对象：相当于像素点
- 数据结构：数据元素相互之间

![](算法1.png)

## 数据结构分类

在计算机科学中，数据结构（data structure）是计算机中存储、组织数据的方式。通常我们可以从逻辑结构和存储结构这两个维度进行分类。

- 逻辑结构:反映数据元素之间的逻辑关系。在设计层面上讲；
- 存储结构:数据结构在计算机中的表示。在实现层面上讲；
![](算法2.png)

## 按逻辑结构分类

- 集合（无逻辑关系）

- 线性结构（线性表）
    - 一维数组。
    - 队列。
    - 栈。
数据结构中的元素存在**一对一**的相互关系；打个比方，我要高考了，但是我数学不好，所以我请了一个数学老师给我单独补课，并且规定在我补课期间，该数学老师不能跟其他人补课，那么我和这个数学老师就是一对一的关系，我们之间的关系就是他跟我补课。还比如排队，每列只站一个人，每列总共十个人，那么他们每个人之间有先后关系，但是都是**一对一**的先后关系。像内存就属于线性结构。他可以使用一元一次方程表示，是连续的，而且前后石油依赖关系的，前后只能一个
    
- 非线性结构。
    - 树。
    数据结构中的元素存在**一对多**的相互关系；比如，一个数学老师给两个或者多个学生补课，那么老师和学生之间就是一对多的关系。
    - 图。
    数据结构中的元素存在**多对多**的相互关系。
    比如我们的交通网，长沙有n条高速公路到达上海，同时上海也有k条高速公路到达长沙，长沙到上海是一对三n的关系，上海到长沙也是一对k的关系，所以长沙和上海是多对多的关系。
    - 多维数组。

    
![](逻辑结构图解.png)

### 集合

数据结构中的集合关系就类似于数学中的集合。
 - 集合中的数据成员是无序的。
 - 每个数据成员在集合中不能重复，仅且只出现一次。
![](集合.png)

 例子：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系。打个比方，我有一个篮子，篮子里面放了一个苹果，一个香蕉，一个梨子。这三种水果除了放在一个篮子里面，他们没有其它联系。这篮子里三种水果就属于一个集合，他们老死不相往来。JS中的Set其实就是一种集合。

### 线性结构

线性结构中的数据元素之间是**一对一**的关系。也就是数据元素一个连接一个
地排列。
 - 用来存放特定的某一个类型的元素
 - 物理结构为顺序表（原生数组）和链表（数据在内存中表示）
 <!-- 自己画一份表示图 -->
> 线性表
 对于线性表来说，第一个元素叫首元素，最后一个元素叫尾元素，除了首元素与尾元素外，中间的元素前边都有一个元素，叫前驱元素，后边也有一个元素叫后继元素，尾元素只有后继元素，首元素只有前驱元素。

 注意⚠️：Array可能是顺序表也可能是链表，链表维护是动态的，需要多大申请多大内存
**线性表的一些操作**
- 可以对线性表进行创建、添加、删除、查找，遍历、读、销毁线性表
链表
**线性表优点：**
- 插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）
- 内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）
- 大小没有固定，拓展很灵活。

**线性表缺点：**
- 不能随机查找，必须从第一个开始遍历，查找效率低

> 一维数组
**特点**：

- 1.静态分配内存（固定需要向内存申请的位置，而且需要给预留位置，这样可能出现：你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。）
- 2.在内存中连续（当需要添加元素的时候，如果申请的位置占满了，就需要转移）
- 3.查找快，数组利用下标定位，时间复杂度为O(1)
- 4.数组插入或删除元素的时间复杂度O(n)（删除时必须要将后面的元素都向前移动，插入时必须将后面的元素都向后移动。如果空间不足，还要重新复制新的空间。）

以下来自算法图解
![](一维数组数据结构.png)
![](一维数组数据结构1.png)

**优势：**
数组，则很方便读取每一个元素的内容。因为知道第一个，就知道了所有的地址。它们是连在一起的。
![](一维数组数据结构2.png)

 > 链表

 **特点：**

 - 1.动态分配内存
 - 2.在内存中是不连续的（内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）
 - 3.链表定位元素
 - 4.大小没有固定，拓展很灵活。

**缺点：**

不能随机查找，必须从第一个开始遍历，查找效率低

![](链表数据结构.png)
![](链表数据结构1.png)

链表插入元素只需要修改它前面的那个元素指向的地址就可以了。
链表删除元素也是只需要修改它前面的那个元素指向的地址就可以了。

**分类**：链表分为单向链表和双向链表，

单链表与双链表的结构图如下：


![单链表](单链表结构图.png)

只能朝一个方向进行遍历（接着后继元素一个一个的遍历，结构相对简单只有后继指针，操作时只需要断一个）

![双向链表](双链表结构.png)

可以从俩个方向遍历，因为有俩个指针，操作起来麻烦，需要操作俩次

> 数组与链表时间复杂度比较

![](数组与链表时间复杂度比较.png)

> 一些常见的问题
**为什么市面上单链表应用比多链表应用广泛一些呢？**

在时间复杂度上来考虑，如果进行查询的话，双链表可以通过二分法查找（从首尾元素开始遍历），时间复杂度是log(n)而单链表只能朝一个方向遍历所以时间复杂度n，事实证明双链表的时间复杂度低，但是双链表每个节点都会比单链表多一个指针（这个指针的length在32位系统中是4字节，在64位系统中是8个字节），占用空间也就大了，这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。

**总结：**

- 插入删除多，读取少。用链表。

- 插入删除少，读取多。用数组。

接下来我们看一下线性结构的衍生结构

#### 栈
![](栈数据结构.png)
**栈**是一种只在一端进行删除、插入操作的线性表， 
**栈顶**进行删除、插入的一端， 
**栈底**不能进行删除、插入的那一端， 
> 栈是一种先入后出表、LIFO(Last In First Out)
##### 栈的几种操作
其实也是一个栈的生命周期

- 1.创建栈结构（空栈）：没有东西的栈（这个时候栈顶就是栈底）
- 2.进栈：在栈顶压入元素（只压一个元素，这个时候栈顶就是栈底）
- 3.退栈：删除或弹出栈顶的元素
- 4.读取栈顶：只看看栈顶的东西，不拿，相当与你舔一舔（有点邪恶了。。）
- 5.清空栈
- 6.销毁栈

##### 栈应用
下边举几个例子：

- 1.**解决括号匹配检查**：检查html标签是否闭合或者简单点就是检查js里括号有没有闭合，具体过程就是查到左括号入栈，查到右括号出栈，最后的结果应该是空栈。
- 2.**浏览器的后退或编辑器的undo功能**

#### 队列
![](队列数据结构.png)
- **队列**是一种只允许在表的一端进行插入，而在另一端删除的线性表
- **队头**：允许删除的一端
- **队尾**：允许插入的一端先进先出表

> 队列是一种先入先出表、FIFO(First In First Out)

##### 队列的几种操作
其实也是一个队列的生命周期
- 创建一个空队列
- 判断队列是否是空队列
- 入队：往队列中插入元素
- 出队：从队列中删除元素
- 求队列头部的值
> 注意⚠️
- 队尾的位置一直在变
- 只有一个元素的队列或者空队列队头就是队尾。
- 有急事的元素可以优先出队列，这是一个可以插队的队列叫`优先队列`
- 环形队列：无队头与队尾，需要指定，最好用链式结构实现，用顺序表结构也可以实现，但是维护起来麻烦，因为队头队尾一直在变。

##### 队列的一些应用
- 排队
- 消息队列
- 任务队列
- 维护打印机任务

#### 串
stream（流）






### 树 

> 基本概念

- `树`是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。简单点说他就是一个由若干个有限节点组成的一个具有层次关系的集合

他是一种操作效率比较高的的数据结构，是一个一对多的关系，和家谱一样

- `节点`:树的每个元素；
- `父节点`：有子节点的节点是子节点的父节点
- `根节点`：最上边的父节点
- `边或权`:任意两个节点是被边连起来的；
- `路径`:任意两个节点是被边连起来的所有边组成路径；
- `叶子节点`:没有分叉的节点
- `兄弟节点`：兄弟节点的前提他们有一个共同的父节点
- `度`：有几个分叉就是几度，度为0的节点就是叶子节点
- `深`:有n层就是n-1深，如果只有一个节点深就为0

注意⚠️

- 一棵树中每两个点之间都有且只有一条路
- 有N个节点就有N-1条边

![](树数据结构.png)

> 如何分辨是不是树

- 单个节点可以看成树；
- 可以有空树
- 树不能形成环路，形成环路就称为图了
![](分辨是不是树.png)










# 算法
算法（algorithm），在数学和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数。

# 算法分类
算法可以分为以下几类：

分治法
递归，将大问题分解成子问题（子问题相互独立，且与原问题相同）、将子问题合并成原问题的解。
动态规划法
递归，记录已解决的子问题的答案，根据子问题求解原问题的解（子问题不独立）。
贪心法
局部最优，根据当前信息做选择。
回溯法
通用的解题法，解空间树（深度优先遍历），找出满足条件的所有解。
分支界限法
解空间（广度优先、最小耗费优先）、界限函数（队列式、优先队列式）。
概率算法
随机性选择，小概率错误（运行时间大幅减少），对同一问题求解两次，可能得到完全不同的解，且所需时间、结果可能会有相当大的差别。
近似算法
求近似解，定义容错界。
算法分类

# 时间复杂度和空间复杂度
我们常常用时间复杂度和空间复杂度来衡量一个算法的效率。

时间复杂度：描述了该算法的运行时间。一个算法的质量优劣将影响到算法乃至程序的效率。

常用的时间复杂度：

O(1)，哈希查找。
O(n)，单层循环。
O(lgn)，二分法。将一个数据集分成两半，然后将分开的每一半再分成两半，依此类推。
O(nlgn)，归并排序。将一个数据集分成两半，然后将分开的每一半再分成两半，依此类推，在此过程中同时遍历每一半数据。
O(n²)，双重循环。
O(n³)，三层循环。
O(2^n)，穷举查找，检查所有子集。
O(n!)，菲波那切数列。
空间复杂度：对一个算法在运行过程中临时占用存储空间大小的量度。

# 算法解题思路
当我们在遇到一个算法的问题时，可以按照以下步骤进行思考，避免走弯路。

枚举法：先不考虑算法复杂度，先用枚举法（暴力法）完成需求。
想办法优化，例如猜生日算法：
穷举法，从 1 月 1 日开始比对，比对到 12 月 31 日。要比对 366 次。
优化 1：先比对 12 次月份，确定完月份，再比对日期，最多要比对 12 + 31 次。
优化 2：使用二分法，先比对 6 月是大是小，确认完月份以后，再用同样的方法比对日期。
递归算法
化繁为简：将一个大事情，分解成 1 步 1 步的小事情。
分而治之：把问题分成多个模块，一块一块的解决。
化虚为实：将不明白的业务，转换成我们熟悉的业务，先理清逻辑，然后再替换回去。
# 前端中的数据结构和算法
上文中介绍了很多理论都是计算机底层的东西，接下来我们看一下前端中能够接触到的数据结构和算法。

# 内存栈和内存堆
函数执行的时候会把局部变量压到一个栈里面。
内存里的堆是指存放 new 处来动态创建变量的地方。
栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。

堆区(heap)：一般是由程序员分配释放，若程序员不释放的话，程序结束时可能由 OS 回收，值得注意的是它与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。

全局区(static)：也叫静态数据内存空间，存储全局变量和静态变量， 全局变量和静态变量的存储是放一块的，初始化的全局变量和静态变量放一块区域，没有初始化的在相邻的另一块区域，程序结束后由系统释放。

文字常量区：常量字符串就是放在这里，程序结束后由系统释放。

程序代码区：存放函数体的二进制代码。

提示

简单类型的变量存在栈里，引用类型变量存在堆里。

堆内存低位向高位增长，栈内存相反。

# Object 和 Map 比较
我们来分析一下 Object 和 Map 这两种数据结构。

相同点：

都是一种以 key-value 存储数据的结构，我们只要输入 key，即可查找到其对应的值。
不同点：

Obejct 的 key 只能是字符串。
Map 可以轻松的获取大小，Object 必须手动追踪大小。
存储结构不一样， Object 有一个专门存放 key 和一个存放 value 的数组，如果能找到 key，则拿到这个 key 的 index 去另外一个数组取出 value 值。当发生散列值冲突时，根据当前 的 index，直接计算下一个查找位置。
# 总结
本章只介绍了数据结构和算法的理论，后面会更新更多相关的实战文章来深入学习。