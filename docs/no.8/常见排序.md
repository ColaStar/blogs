# 10大经典排序算法

## 排序算法分类：
十种常见的排序算法可以分为俩大类：
- 比较类算法：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn),因此也称为非线性时间比较类的排序。

- 非比较类排序：不同比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以非线性时间运行，因此也称为线性时间非比较类排序。

![](排序算法分类.png)

> 排序算法对比

![](排序算法对比.png)

### 冒泡排序

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

>算法描述

- 1.比较相邻的元素，如果第一个比第二个大的化，就交换位置，
- 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 3.针对所有的元素重复以上的步骤，除了最后一个；
- 4.重复以上3步，直到排序完成

> 动图演示

![](冒泡排序.gif)

代码实现
```
function bubbleSort(arr){
    for(var i = 0;i<arr.length;i++){
        for(var j = 0;j<arr.length;j++){
            if(arr[j]>arr[j+1]){
                var temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    return arr
}
```

## 选择排序（Selection Sort）

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

>算法描述

- n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。
- 每次循环 从第n个开始找到后边所有书的最小值，然后与第n个互换位置
- n-1趟结束，数组有序化了。

> 动图演示

![](选择排序.gif)

代码实现
```
function selectionSort(arr){
    for(var i = 0;i < arr.length;i++){
        var minIndex = i
        for(var j=i+1;j < arr.length;j++){
          //找到最小的值；
            if(arr[j] < arr[minIndex]){
                minIndex = j  //// 将最小数的索引保存
            }
        }
        var temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp
    }
    return arr
}
```

## 插入排序

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。


```
function insertionSort(arr){
  for(var i = 0;i<arr.length;i++){
      
  }
}
```
