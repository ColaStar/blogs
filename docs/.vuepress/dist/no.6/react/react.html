<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>react</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.3e9a3537.css" as="style"><link rel="preload" href="/assets/js/app.8af69535.js" as="script"><link rel="preload" href="/assets/js/2.d648d88f.js" as="script"><link rel="preload" href="/assets/js/76.5d637a94.js" as="script"><link rel="prefetch" href="/assets/js/10.97610f94.js"><link rel="prefetch" href="/assets/js/11.59159f0c.js"><link rel="prefetch" href="/assets/js/12.efe3f21c.js"><link rel="prefetch" href="/assets/js/13.4a4c78f6.js"><link rel="prefetch" href="/assets/js/14.9b72df4f.js"><link rel="prefetch" href="/assets/js/15.3a6d7ce1.js"><link rel="prefetch" href="/assets/js/16.eac41172.js"><link rel="prefetch" href="/assets/js/17.b13e21b8.js"><link rel="prefetch" href="/assets/js/18.5f5840be.js"><link rel="prefetch" href="/assets/js/19.3c8bc831.js"><link rel="prefetch" href="/assets/js/20.2fd802c3.js"><link rel="prefetch" href="/assets/js/21.fe1c3bc8.js"><link rel="prefetch" href="/assets/js/22.b8dff5d8.js"><link rel="prefetch" href="/assets/js/23.4e04791f.js"><link rel="prefetch" href="/assets/js/24.48f5c1ac.js"><link rel="prefetch" href="/assets/js/25.c582d482.js"><link rel="prefetch" href="/assets/js/26.5548d10a.js"><link rel="prefetch" href="/assets/js/27.78bcd32b.js"><link rel="prefetch" href="/assets/js/28.2b769fda.js"><link rel="prefetch" href="/assets/js/29.82f7b390.js"><link rel="prefetch" href="/assets/js/3.06e36435.js"><link rel="prefetch" href="/assets/js/30.0f65a25c.js"><link rel="prefetch" href="/assets/js/31.572dbd84.js"><link rel="prefetch" href="/assets/js/32.dc820faa.js"><link rel="prefetch" href="/assets/js/33.c4d79304.js"><link rel="prefetch" href="/assets/js/34.8a5f4a08.js"><link rel="prefetch" href="/assets/js/35.2c795c98.js"><link rel="prefetch" href="/assets/js/36.789c9c9e.js"><link rel="prefetch" href="/assets/js/37.3b778f0f.js"><link rel="prefetch" href="/assets/js/38.6d1dd60a.js"><link rel="prefetch" href="/assets/js/39.cf555500.js"><link rel="prefetch" href="/assets/js/4.84833d8d.js"><link rel="prefetch" href="/assets/js/40.38d7da84.js"><link rel="prefetch" href="/assets/js/41.4eaa1dc4.js"><link rel="prefetch" href="/assets/js/42.5c79ceb8.js"><link rel="prefetch" href="/assets/js/43.58226bd6.js"><link rel="prefetch" href="/assets/js/44.722d8e47.js"><link rel="prefetch" href="/assets/js/45.8c4a2969.js"><link rel="prefetch" href="/assets/js/46.e4e5942d.js"><link rel="prefetch" href="/assets/js/47.e571d66e.js"><link rel="prefetch" href="/assets/js/48.3779b538.js"><link rel="prefetch" href="/assets/js/49.b62a8e2a.js"><link rel="prefetch" href="/assets/js/5.751146ce.js"><link rel="prefetch" href="/assets/js/50.840600be.js"><link rel="prefetch" href="/assets/js/51.907d2772.js"><link rel="prefetch" href="/assets/js/52.be2fc8cd.js"><link rel="prefetch" href="/assets/js/53.32c22580.js"><link rel="prefetch" href="/assets/js/54.7c74f55b.js"><link rel="prefetch" href="/assets/js/55.67be651f.js"><link rel="prefetch" href="/assets/js/56.3d130b37.js"><link rel="prefetch" href="/assets/js/57.c0e4f872.js"><link rel="prefetch" href="/assets/js/58.64090566.js"><link rel="prefetch" href="/assets/js/59.35dd6971.js"><link rel="prefetch" href="/assets/js/6.8e7ccfda.js"><link rel="prefetch" href="/assets/js/60.482cf2bf.js"><link rel="prefetch" href="/assets/js/61.a19ad285.js"><link rel="prefetch" href="/assets/js/62.7b18e1a1.js"><link rel="prefetch" href="/assets/js/63.5c77d49e.js"><link rel="prefetch" href="/assets/js/64.dd4fb2a7.js"><link rel="prefetch" href="/assets/js/65.48fd33a6.js"><link rel="prefetch" href="/assets/js/66.0d04e98a.js"><link rel="prefetch" href="/assets/js/67.07ba1b61.js"><link rel="prefetch" href="/assets/js/68.2fb5db48.js"><link rel="prefetch" href="/assets/js/69.61df01c4.js"><link rel="prefetch" href="/assets/js/7.df0e3edb.js"><link rel="prefetch" href="/assets/js/70.199971e9.js"><link rel="prefetch" href="/assets/js/71.d7777450.js"><link rel="prefetch" href="/assets/js/72.4d262caf.js"><link rel="prefetch" href="/assets/js/73.1924c279.js"><link rel="prefetch" href="/assets/js/74.f907ae48.js"><link rel="prefetch" href="/assets/js/75.7d8db399.js"><link rel="prefetch" href="/assets/js/77.931da172.js"><link rel="prefetch" href="/assets/js/78.27b3debd.js"><link rel="prefetch" href="/assets/js/79.86a40c03.js"><link rel="prefetch" href="/assets/js/8.58e59b8f.js"><link rel="prefetch" href="/assets/js/80.42daa631.js"><link rel="prefetch" href="/assets/js/81.2eb1325e.js"><link rel="prefetch" href="/assets/js/82.5fb6983f.js"><link rel="prefetch" href="/assets/js/83.482a58ff.js"><link rel="prefetch" href="/assets/js/84.f4b8414f.js"><link rel="prefetch" href="/assets/js/85.1c79c80f.js"><link rel="prefetch" href="/assets/js/86.4eae8bf0.js"><link rel="prefetch" href="/assets/js/87.b3991055.js"><link rel="prefetch" href="/assets/js/88.24233d08.js"><link rel="prefetch" href="/assets/js/89.7e4bb512.js"><link rel="prefetch" href="/assets/js/9.f8806773.js"><link rel="prefetch" href="/assets/js/90.a767744f.js"><link rel="prefetch" href="/assets/js/91.653caad6.js"><link rel="prefetch" href="/assets/js/92.7fe1d11c.js"><link rel="prefetch" href="/assets/js/93.793830f9.js"><link rel="prefetch" href="/assets/js/94.a55f0129.js"><link rel="prefetch" href="/assets/js/95.17c4d61f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3e9a3537.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" aria-hidden="true" class="header-anchor">#</a> react</h1> <h2 id="介绍与发展"><a href="#介绍与发展" aria-hidden="true" class="header-anchor">#</a> 介绍与发展</h2> <ul><li>react是Feckbook开发的一款用来构建用户见面的js库，他只是做一个views，专门是用来用户界面的库。</li> <li>Virtual DOM 是一个模拟DOM树的Javascript对象。React使用 Virtual DOM来渲染UI，同时监听Virtual DOM上的数据变化并自动前一这些变化到UI上</li></ul> <ul><li><p>传入属性 构建Virtual DOM，状态对应一个内容。</p></li> <li><p>JSX 是React定义的一种Javascript语法扩展，类似与XML。JSX是可选的，我们完全可以使用Javascript来编写React应用，不过JSX提供了一套更为简单的方式；来写react的应用。</p></li></ul> <p><img src="react%E5%8F%91%E5%B1%95.png" alt=""></p> <p>19年已经更新到了16.8的版本</p> <h2 id="react开发环境与ecmascript6"><a href="#react开发环境与ecmascript6" aria-hidden="true" class="header-anchor">#</a> React开发环境与EcmaScript6</h2> <h2 id="jsx使用与介绍"><a href="#jsx使用与介绍" aria-hidden="true" class="header-anchor">#</a> JSX使用与介绍</h2> <h3 id="优点"><a href="#优点" aria-hidden="true" class="header-anchor">#</a> 优点</h3> <ul><li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li> <li>它是类型安全的，在编译过程中就能发现错误。</li> <li>使用 JSX 编写模板更加简单快速。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
</code></pre></div><p>这种看起来可能有些奇怪的标签语法既不是字符串也不是 <code>HTML</code>。</p> <p>它被称为 <code>JSX，</code> 一种 <code>JavaScript</code> 的语法扩展。 我们推荐在 <code>React</code> 中使用 <code>JSX</code> 来描述用户界面。</p> <p><code>JSX</code> 是在 <code>JavaScript</code> 内部实现的。</p> <p>我们知道元素是构成 <code>React</code> 应用的最小单位，<code>JSX</code> 就是用来声明 <code>React</code> 当中的元素。</p> <p>与浏览器的 <code>DOM</code> 元素不同，<code>React</code> 当中的元素事实上是普通的对象，<code>React DOM</code> 可以确保 浏览器 <code>DOM</code> 的数据内容与 <code>React</code> 元素保持一致。</p> <p>要将 <code>React</code> 元素渲染到根 <code>DOM</code> 节点中，我们通过把它们都传递给 <code>ReactDOM.render()</code> 的方法来将其渲染到页面上：</p> <blockquote><p>ES5写法
<img src="reactes5.png" alt=""></p></blockquote> <blockquote><p>ES6写法
<img src="reactes6.png" alt=""></p></blockquote> <blockquote><p>react组件怎么用呢
<img src="react%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E7%94%A8%E5%91%A2.png" alt=""></p></blockquote> <blockquote><p>Dom diff</p></blockquote> <p><img src="reactdomdiff.png" alt=""></p> <p><img src="reactdomdiff%E4%BE%8B%E5%AD%901.png" alt=""></p> <p>Dom diff是为渲染的性能，最小化的一个渲染机制</p> <blockquote><p>JSX注意事项
<img src="JSX%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.png" alt=""></p></blockquote> <h2 id="非dom属性介绍"><a href="#非dom属性介绍" aria-hidden="true" class="header-anchor">#</a> 非Dom属性介绍</h2> <p>ref与key</p> <p><img src="%E9%9D%9EDom%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D.png" alt=""></p> <h2 id="webapp缺点与优点"><a href="#webapp缺点与优点" aria-hidden="true" class="header-anchor">#</a> webApp缺点与优点</h2> <p>缺点：</p> <ul><li>1.Web基于DOM，而DOM很慢</li> <li>2.DOM拖慢JavaScript。</li> <li>3。网页是单线程的</li> <li>网页没有硬件加速</li></ul> <p>优点：</p> <ul><li>1.跨平台：所有系统都能使用</li> <li>2.免安装：打开浏览器就能使用</li> <li>3.快速部署：升级只需在服务器更新代码</li> <li>4.超链接：可以与其他网站互联，可以被搜索引擎检索</li></ul> <p>react-canvas这个包是基于canvas和react的把jsx语法化成canvas</p> <h2 id="属性、状态的介绍与用法以及对比"><a href="#属性、状态的介绍与用法以及对比" aria-hidden="true" class="header-anchor">#</a> 属性、状态的介绍与用法以及对比</h2> <blockquote><p>属性（props）的介绍与用法</p></blockquote> <p>属性 是一个事物的性质与关系往往是与生俱来的，无法改变的</p> <p><strong>属性的用法</strong></p> <ul><li>可以传入变量、number、string、数组、等</li> <li>数组形式用法（需要加key防止整体重新渲染）</li></ul> <p><img src="reactprops%E7%94%A8%E6%B3%95.png" alt=""></p> <p><img src="reactprops%E6%95%B0%E7%BB%84%E7%94%A8%E6%B3%95.png" alt=""></p> <p><strong>默认 Props</strong></p> <p>通过组件类的 defaultProps 属性为 props 设置默认值，</p> <div class="language- extra-class"><pre class="language-text"><code>//属性与状态
class HelloMessage extend React.Component{
    render(){
        retun &lt;h1 onClick={this.handle} className=&quot;h1&quot;&gt;{this.props.name}&lt;/h1&gt;
        )
    }
}
HelloMessage.defaultProps = {
  name: 'Runoob'
};
ReactDOM.reder(&lt;HelloMessage name=&quot;吕鉴&quot; name:{吕鉴} name={123} name={this.data}/&gt;,
document.getElementById('exampdayle'))
</code></pre></div><blockquote><p>状态state</p></blockquote> <p>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p> <p>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。</p> <ul><li>事物所处的状态</li> <li>状态是由事物自行处理的，不断变化的，</li> <li>对于React来讲一切变化全部基于状态，</li> <li>通过setState进行改变</li> <li>每次执行<code>setState</code>时<code>render</code>进行<code>Dom diff</code>算法进行重新计算，发生变化后进行更新,</li></ul> <p>缺点：即每次state改变都会进行重排</p> <p>如何优化呢？</p> <p><img src="reactstate.png" alt=""></p> <blockquote><p>属性状态对比？</p></blockquote> <ul><li>都是纯js对象</li> <li>都会触发render更新</li> <li>props 是不可变的,如果需要改变就需要把state放到props上边，而 state 可以根据与用户交互来改变。</li> <li>但是props只有一次触发render只传递一次 ，state一直在触发，即实时修改</li> <li>都具有确定性</li> <li>组件在运行时需要修改的数据就是状态</li></ul> <p><img src="react%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%8A%B6%E6%80%81%E5%AF%B9%E6%AF%94.png" alt=""></p> <p>状态是自己的属性是组件之间的</p> <blockquote><p>单向数据流</p></blockquote> <p>任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。</p> <p>如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。</p> <h2 id="生命周期"><a href="#生命周期" aria-hidden="true" class="header-anchor">#</a> 生命周期</h2> <p><strong>React v16.3之前生命周期</strong> <img src="react16.3%E4%B9%8B%E5%89%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""> <strong>React v16.3生命周期</strong> <img src="react16.3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p> <p><strong>React v16.4生命周期</strong> <img src="react16.4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p> <blockquote><p>生命周期介绍与初始化阶段
组件本质上是状态机，输入确定，输出确定。状态发生转换时会触发不同的钩子函数，从而让开发者有机会做出响应。可以用事件的思路来理解状态。
初始化-&gt; 运行中-&gt; 销毁
<img src="react%E5%88%9D%E5%A7%8B%E5%8C%96%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="">
getDeaultProps
getInitalState
componentWill
运行中阶段
运行中拿到上拿到下</p></blockquote> <p>componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。</p> <p>shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。
可以在你确认不需要更新组件时使用。
默认return true</p> <p>componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。</p> <p>render</p> <p>componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。</p> <blockquote><p>销毁阶段</p></blockquote> <p>componentDidUnmount</p> <h2 id="组件介绍"><a href="#组件介绍" aria-hidden="true" class="header-anchor">#</a> 组件介绍</h2> <ul><li>普通组件component</li> <li>纯组件PureComponent
<code>PureComponent</code>的自动为我们添加的<code>shouldComponentUpate</code>函数</li> <li>纯函数组件
没有自身的状态，相同的props输入必然会获得完全相同的组件展示。不需要关心组件的一些生命周期函数和渲染的钩子更简洁。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const Button = ({ day }) =&gt; {
  return (
    &lt;div&gt;
      &lt;button className=&quot;btn btn-warning&quot;&gt;我是 {day.name}&lt;/button&gt;
    &lt;/div&gt;
  );
};
const message = {
  name:'纯函数组件'
}
class Greeting extends Component {
  render() {
    return &lt;Button day={message}&gt;&lt;/Button&gt;;
  }
}
</code></pre></div><ul><li>高阶组件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//注值 localStorage.username = &quot;老袁&quot;
const wrapWithUsername = WrappedComponent =&gt; {
  class NewComponent extends Component {
    constructor() {
      super();
      this.state = {
        username: &quot;&quot;
      };
    }
    componentWillMount() {
      let username = localStorage.getItem(&quot;username&quot;);
      this.setState({
        username: username
      });
    }

    render() {
      return &lt;WrappedComponent username={this.state.username} /&gt;;
    }
  }

  return NewComponent;
};
class Welcome extends Component {
  render() {
    return &lt;div className=&quot;text-warning&quot;&gt;welcome {this.props.username}&lt;/div&gt;;
  }
}
//升级高阶组件
Welcome = wrapWithUsername(Welcome);

class Goodbye extends Component {
  render() {
    return &lt;div className=&quot;text-info&quot;&gt;goodbye {this.props.username}&lt;/div&gt;;
  }
}
//升级高阶组件
Goodbye = wrapWithUsername(Goodbye);
class Greeting extends Component {
  render() {
    return (
      &lt;&gt;
        &lt;Welcome /&gt; &lt;Goodbye /&gt;
      &lt;/&gt;
    );
  }
}
</code></pre></div><ul><li>组件插槽
提供了一个顶级的方法，使得我们有能力把一个子组件渲染到父组件 DOM 层级以外的 DOM 节点上。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//组件插槽
const portalElm = document.createElement('div');
portalElm.className=&quot;txtcenter&quot;
document.body.appendChild(portalElm)

class App extends React.Component {
  state = {
    show: true,
  }

  handleClick = () =&gt; {
    this.setState({
      show: !this.state.show,
    })
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button className=&quot;btn btn-primary&quot; onClick={this.handleClick}&gt;动态展现Portal组件&lt;/button&gt;
        {this.state.show ? (
          &lt;div&gt;{ReactDOM.createPortal(&lt;span&gt;Portal组件&lt;/span&gt;, portalElm)}&lt;/div&gt;
        ) : null}
      &lt;/div&gt;
    )
  }
}
</code></pre></div><p>React可控与不可控控件</p> <div class="language- extra-class"><pre class="language-text"><code>//不可控控件
&lt;input defaultvalue={'aaa'}/&gt;
通过refs或者findDOMNode去获取值
//可控空间
&lt;input value={this.state.name}/&gt;
直接取this.state获取
</code></pre></div><p>可控控件的好处</p> <ul><li>符合react的数据流</li> <li>数据存储在state中便于取用</li> <li>便于对数据进行处理</li></ul> <p>React不同表单元素的使用
label  HtmlFor</p> <p>事件处理函数以及this
驼峰
this处理使用bind或剪头函数</p> <p>flux架构</p> <p>、</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8af69535.js" defer></script><script src="/assets/js/2.d648d88f.js" defer></script><script src="/assets/js/76.5d637a94.js" defer></script>
  </body>
</html>
