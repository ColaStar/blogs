(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{185:function(n,e,a){"use strict";a.r(e);var c=a(0),t=Object(c.a)({},function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"词法作用域和动态作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域和动态作用域","aria-hidden":"true"}},[n._v("#")]),n._v(" 词法作用域和动态作用域")]),n._v(" "),a("p",[n._v("作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。")]),n._v(" "),a("p",[n._v("因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。")]),n._v(" "),a("p",[n._v("而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var value = 1;\n\nfunction foo() {\n  console.log(value);\n}\n\nfunction bar() {\n  var value = 2;\n  foo();\n}\n\nbar();\n\n// 1\n\n// 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var scope = "global scope";\nfunction checkscope() {\n  var scope = "local scope";\n  function f() {\n    return scope;\n  }\n  return f()\n}\ncheckscope();\nvar scope = "global scope";\nfunction checkscope() {\n  var scope = "local scope";\n  function f() {\n    return scope;\n  }\n  return f;\n}\ncheckscope()();\n\n都返回 local scope。 两者的区别是什么？\n\x3c!--下边是闭包，上边是函数执行 --\x3e\n')])])])])},[],!1,null,null,null);e.default=t.exports}}]);