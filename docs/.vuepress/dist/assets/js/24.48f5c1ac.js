(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{127:function(t,a,s){"use strict";s.r(a);var e=s(0),n=Object(e.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"linux笔记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux笔记","aria-hidden":"true"}},[t._v("#")]),t._v(" Linux笔记")]),t._v(" "),s("h2",{attrs:{id:"linux操作系统的介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux操作系统的介绍","aria-hidden":"true"}},[t._v("#")]),t._v(" Linux操作系统的介绍")]),t._v(" "),s("blockquote",[s("p",[t._v("Linux的历史")])]),t._v(" "),s("p",[t._v("诞生于1991年发明人就叫Linux，\nLinux存在不同的Linux版本（ubuntu（桌面市场），RedHat（服务器市场）、CentOs（服务器市场上）、Debain、Fedora（桌面市场）、SuSE、OpenUSE、TurboLinux、kali（安全方面的）），但他们都市用的是Linux内核，Linux可安装在各种计算机硬件设备中，比如手机、电脑、路由器、视频游戏控制台、台式计算机大型机和超级电脑。Linux的终端比window的终端强大很多。文本界面命令行vim与图形界面")]),t._v(" "),s("blockquote",[s("p",[t._v("选择Linux的发行版本\n服务器市场：RedHat、CentOs（Minimal ISO）\n桌面市场：Ubuntu、Fadora\nRedHat其实是商业型的操作系统。\nCentOs是RedHat包装过的。\nUbuntu在中国是非常流行的。")])]),t._v(" "),s("p",[t._v("LTS叫长期支持的。")]),t._v(" "),s("p",[t._v("虚拟机指通过软件模拟的具有完整硬件系统内功能的运行在一个完全隔离环境中的完整计算机系统。流行的虚拟及软件有：CMware、VirtualBox、VirtualPC，他们都能在windows系统上虚拟出多个计算机。")]),t._v(" "),s("p",[t._v("在windows系统中安装Linux系统"),s("br"),t._v("\n1.下载最新版的虚拟机与Linux版本"),s("br"),t._v("\n2.后打开虚拟机装Linux版本。\n3.设置用户信息与语言")]),t._v(" "),s("h2",{attrs:{id:"linux的目录结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux的目录结构","aria-hidden":"true"}},[t._v("#")]),t._v(" Linux的目录结构")]),t._v(" "),s("ul",[s("li",[t._v("/ 根目录")]),t._v(" "),s("li",[s("span",{staticStyle:{color:"red"}},[t._v("/bin - 重要的二进制 (binary) 应用程序")]),t._v("。bin就是binary，二进制。/bin目录放置可执行文件，root和一般账号都可以使用，如cat, chmod, mv, mkdir等。其实系统有很多放置执行文件的目录，但/bin 目录比较特殊，因为/bin 放置的是在单用户模式下还能够被操作的命令")]),t._v(" "),s("li",[t._v("/boot - 启动 (boot) 配置文件，这个目录主要存放开机会使用的文件，如Linux内核和系统启动文件")]),t._v(" "),s("li",[t._v("/dev - 设备 (device) 文件，存放所有设备文件，包括硬盘、分区、键盘、鼠标、USB、tty等。注：在Linux系统上，任何设备与接口设备都是以文件的形式存在于这个目录当中的")]),t._v(" "),s("li",[s("span",{staticStyle:{color:"red"}},[t._v("/etc - 配置文件、启动脚本等 (etc)")]),t._v("，例如/etc/passwd存放用户账户信息，/etc/hostname文件存放主机名")]),t._v(" "),s("li",[s("span",{staticStyle:{color:"red"}},[t._v("/home - 本地用户主 (home) 目录")])]),t._v(" "),s("li",[t._v("/lib - 系统库 (libraries) 文件，存放开机时会用到的函数库，以及/bin和/sbin目录下的命令调用的函数库")]),t._v(" "),s("li",[t._v("/lost+found - 在根 (/) 目录下提供一个遗失+查找(lost+found) 系统")]),t._v(" "),s("li",[t._v("/media - 挂载可移动介质 (media)，诸如 CD、数码相机等，它下面存放可删除的设备，包括软盘，光盘，DVD等设备文件")]),t._v(" "),s("li",[t._v("/mnt - 挂载 (mounted) 文件系统")]),t._v(" "),s("li",[t._v("/opt - 提供一个供可选的 (optional) 应用程序安装目录")]),t._v(" "),s("li",[s("span",{staticStyle:{color:"red"}},[t._v("/proc - 特殊的动态目录，这个目录本身是一个虚拟文件系统。它放置的数据都是在内存当中，例如系统内核，进程等")])]),t._v(" "),s("li",[t._v("/root - root (root) 用户主文件夹，读作“slash-root”")]),t._v(" "),s("li",[t._v("/sbin - 重要的系统二进制 (system binaries) 文件，这些命令只有root用户才能用设置系统，其他用户最多只能用来“查询”而已")]),t._v(" "),s("li",[t._v("/sys - 系统 (system) 文件，这个目录跟/proc 非常类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。这个目录同样不占硬盘容量")]),t._v(" "),s("li",[t._v("/tmp - 临时(temporary)文件，就是用来存放临时文件的地方，所有用户都可以访问。该目录不要放重要数据")]),t._v(" "),s("li",[t._v("/usr - 包含绝大部分所有用户(users)都能访问的应用程序和文件")]),t._v(" "),s("li",[t._v("/var - 经常变化的(variable)文件，诸如日志或数据库等")]),t._v(" "),s("li",[s("span",{attrs:{color:"red"}},[t._v("/run - 要特别注意的是：它使用tmpfs文件系统，这是一种存储在内存中的临时文件系统，当机器关闭的时候，文件系统自然就被清空了")])])]),t._v(" "),s("h2",{attrs:{id:"linux命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux命令","aria-hidden":"true"}},[t._v("#")]),t._v(" Linux命令")]),t._v(" "),s("h3",{attrs:{id:"_1-常用命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-常用命令","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. 常用命令")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("查看帮助文档")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" command --help\n man command    [manual]\n")])])])]),t._v(" "),s("li",[s("p",[t._v("ls（选项）（参数） 查看指定目录下的内容")]),t._v(" "),s("p",[s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$  -a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；\n$  -l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等\n$  -t：用文件和目录的更改时间排序；\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 指定要显示列表的目录，也可以是具体的文件\n$ 文件或目录支持正则的写法  *?[]\n")])])])]),t._v(" "),s("li",[s("p",[t._v("which ( 命令 )")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 可执行程序的绝对路径\n")])])])]),t._v(" "),s("li",[s("p",[t._v("cd (目录)")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('$ 用于切换当前工作目录至指定目录\n$ 可为绝对路径或相对路径\n$ 目录名称省略，则变换至使用者的 home 目录 ，"~"也标识home目录\n$ "-" 快速回到上一次所在目录\n$ "/" 表示根目录\n$ "." 则是表示目前所在的目录\n$ ".." 则表示目前目录位置的上一层目录\n')])])])]),t._v(" "),s("li",[s("p",[t._v("pwd")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称\n")])])])])]),t._v(" "),s("p",[t._v("— clear\n"),s("code",[t._v("$ 清空屏幕")])]),t._v(" "),s("h3",{attrs:{id:"_2-文件管理常用命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-文件管理常用命令","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.文件管理常用命令")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("ls")])]),t._v(" "),s("li",[s("p",[t._v("touch (文件名)")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件\n")])])])]),t._v(" "),s("li",[s("p",[t._v("echo (输出内容)")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('$ 在命令行输出内容\n$ 用 ">" 符号可以重定向\n$ 用 ">>"符合可以追加内容\n')])])])]),t._v(" "),s("li",[s("p",[t._v("cat (选项) (参数)\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -n 或 --number：由 1 开始对所有输出的行数编号。\n\n$ -b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要输出的文件\n")])])])]),t._v(" "),s("li",[s("p",[t._v("more (选项) (参数)\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -num 一次显示的行数\n$ +num 从第 num 行开始显示\n$ +/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要显示的文件\n")])])]),s("p",[s("strong",[t._v("常用的操作命令")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ Enter 向下n行，需要定义。默认为1行\n$ Ctrl+F 向下滚动一屏\n$ 空格键 向下滚动一屏\n$ Ctrl+B 返回上一屏\n$ = 输出当前行的行号\n$ ：f 输出文件名和当前行的行号\n$ V 调用vi编辑器\n$ q 退出more\n")])])])]),t._v(" "),s("li",[s("p",[t._v("gedit 文件名   编辑指定的文件")])]),t._v(" "),s("li",[s("p",[t._v("vi  文件名     编辑指定的文件")])]),t._v(" "),s("li",[s("p",[t._v("mkdir (选项) (参数)\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -p 可以创建递归目录\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 指定要创建的目录（$(date +%Y%m%d)时间戳文件夹）\n")])])])]),t._v(" "),s("li",[s("p",[t._v("rmdir (选项)  (参数)\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 删除空的目录\n$ -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除\n 如：rmdir -p aaa/bbb\n$ 在工作目录下的 aaa 目录中，删除名为 bbb 的子目录。若 bbb 删除后，aaa 目录成为空目录，则 BBB 亦予删除,否则只删除bbb，aaa则不予删除\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要删除的目录\n")])])])]),t._v(" "),s("li",[s("p",[t._v("rm (选项) (参数)\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -i 删除前逐一询问确认。\n$ -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n$ -r 将目录及以下之档案亦逐一删除。\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要删除的文件或是目录\n")])])])]),t._v(" "),s("li",[s("p",[t._v("cp (选项) source dest\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('$ -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\n$ -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\n$ -f：覆盖已经存在的目标文件而不给出提示。\n$ -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。\n$ -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n$ -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\n$ -l：不复制文件，只是生成链接文件。\n')])])]),s("p",[s("strong",[t._v("source")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要复制的文件名\n")])])]),s("p",[s("strong",[t._v("dest")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 目标地址\n")])])])]),t._v(" "),s("li",[s("p",[t._v("mv (选项) source dest\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;\n$ -f: 在mv操作要覆盖某已有的目标文件时不给任何指示;\n")])])]),s("p",[s("strong",[t._v("source")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要移动或修改的文件名\n")])])]),s("p",[s("strong",[t._v("dest")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" 要移动或修改的目标地址\n")])])])]),t._v(" "),s("li",[s("p",[t._v("ln (选项) source dest\n"),s("code",[t._v("ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接")])]),t._v(" "),s("p",[s("strong",[t._v("硬链接")])]),t._v(" "),s("p",[t._v("介绍：\n硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.硬链接，以文件副本的形式存在。但不占用实际空间。\n2.不允许给目录创建硬链接\n3. ln  source dest\n4. 用 rm 命令 删除硬链接\n")])])]),s("p",[s("strong",[t._v("软连接")])]),t._v(" "),s("p",[t._v("介绍：")]),t._v(" "),s("p",[t._v("另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式\n2.软链接可以 跨文件系统 ，硬链接不可以\n3. ln -s source dest\n4. 用 rm 命令 删除硬链接\n")])])])]),t._v(" "),s("li",[s("p",[t._v("grep (选项) (参数) 从文件里面找内容\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要查找的范式\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要查询的文件\n")])])])]),t._v(" "),s("li",[s("p",[t._v("find path -option  找文件")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('$ find . -name "*.c" 前目录及其子目录下所有延伸档名是 c 的文件列出来\n$ find . -type f     将目前目录其其下子目录中所有一般文件列出\n$ find . -ctime -20  将目前目录及其子目录下所有最近 20 天内更新过的文件列出\n')])])])])]),t._v(" "),s("h3",{attrs:{id:"_3-文件解压缩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-文件解压缩","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.文件解压缩")]),t._v(" "),s("p",[t._v("Linux 上的压缩包文件格式，除了 Windows 最常见的＊.zip、＊.rar、.7z 后缀的压缩文件，还有 .gz、.xz、.bz2、.tar、.tar.gz、.tar.xz、tar.bz2")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("tar (选项) dest (mode) source\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -c 创建打包文件。\n$ -v 显示打包过程\n$ -f 指定打包后的文件名\n$ -x 解包\n$ -z 压缩格式 gzip\n$ -j 压缩格式  bz2\n")])])]),s("p",[s("strong",[t._v("mode")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -C 解压到指定目录\n")])])]),s("p",[s("strong",[t._v("dest")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 打包后的文件名  xxx.tar\n$ 打包并压缩成gzip格式     xxx.tar.gz\n$ 打包并压缩成bz2格式     xxx.tar.bz2\n")])])]),s("p",[s("strong",[t._v("source")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要打包的文件\n")])])])]),t._v(" "),s("li",[s("p",[t._v("zip 压缩")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ zip dest source\n")])])])]),t._v(" "),s("li",[s("p",[t._v("unzip (-d) (path) 解压")])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("unzip [-cflptuvz][-agCjLMnoqsVX][-P <密码>][.zip文件][文件][-d <目录>][-x <文件>] 或 unzip [-Z]\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("    -c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。\n    -f 更新现有的文件。\n    -l 显示压缩文件内所包含的文件。\n    -p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。\n    -t 检查压缩文件是否正确。\n    -u 与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。\n    -v 执行是时显示详细的信息，参数用于查看压缩文件目录信息，但是不解压该文件。\n    -z 仅显示压缩文件的备注文字。\n    -a 对文本文件进行必要的字符转换。\n    -b 不要对文本文件进行字符转换。\n    -C 压缩文件中的文件名称区分大小写。\n    -j 不处理压缩文件中原有的目录路径。\n    -L 将压缩文件中的全部文件名改为小写。\n    -M 将输出结果送到more程序处理。\n    -n 解压缩时不要覆盖原有的文件。\n    -o 不必先询问用户，unzip执行后覆盖原有文件。\n    -P<密码> 使用zip的密码选项。\n    -q 执行时不显示任何信息。\n    -s 将文件名中的空白字符转换为底线字符。\n    -V 保留VMS的文件版本信息。\n    -X 解压缩时同时回存文件原来的UID/GID。\n    [.zip文件] 指定.zip压缩文件。\n    [文件] 指定要处理.zip压缩文件中的哪些文件。\n    -d<目录> 指定文件解压缩后所要存储的目录。\n    -x<文件> 指定不要处理.zip压缩文件中的哪些文件。\n    -Z unzip -Z等于执行zipinfo指令。\n")])])]),s("ul",[s("li",[t._v("rar 压缩")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("# 使用a参数添加一个目录～到一个归档文件中，如果该文件不存在就会自动创建\nrar a test.rar .\n\n# 从指定压缩包文件中删除某个文件\nrar d test.rar .bashrc\n# 查看不解压文件\nrar l test.rar\n\n使用 unrar 解压 rar 文件\n# 全路径解压\nunrar x test.rar\n# 去掉路径解压\nmkdir tmp\nunrar e test.rar tmp/\n")])])]),s("h3",{attrs:{id:"_4-磁盘管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-磁盘管理","aria-hidden":"true"}},[t._v("#")]),t._v(" 4.磁盘管理")]),t._v(" "),s("ul",[s("li",[t._v("cd  切换目录")]),t._v(" "),s("li",[t._v("df (选项) (参数)   查看磁盘使用情况\n"),s("strong",[t._v("选项")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -h 可读的格式显示\n$ -a, --all 包含所有的具有 0 Blocks 的文件系统\n")])])]),s("strong",[t._v("参数")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ df -h /run\n")])])])]),t._v(" "),s("li",[t._v("du (选项) (参数) 查看当前目录的存储状态\n"),s("strong",[t._v("选项")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -h 可读的格式显示\n")])])]),s("strong",[t._v("参数")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ du -h /run\n")])])])])]),t._v(" "),s("h3",{attrs:{id:"_5-文件传输"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-文件传输","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.文件传输")]),t._v(" "),s("ul",[s("li",[t._v("scp (可选参数) file_source file_target\n"),s("strong",[t._v("可选参数")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -1： 强制scp命令使用协议ssh1\n$ -2： 强制scp命令使用协议ssh2\n$ -4： 强制scp命令只使用IPv4寻址\n$ -6： 强制scp命令只使用IPv6寻址\n$ -B： 使用批处理模式（传输过程中不询问传输口令或短语）\n$ -C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）\n$ -p：保留原文件的修改时间，访问时间和访问权限。\n$ -q： 不显示传输进度条。\n$ -r： 递归复制整个目录。\n$ -v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。\n$ -c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。\n$ -F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。\n$ -i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。\n$ -l limit： 限定用户所能使用的带宽，以Kbit/s为单位。\n$ -o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，\n$ -P port：注意是大写的P, port是指定数据传输用到的端口号\n$ -S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n")])])]),s("strong",[t._v("file_source")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要拷贝的源文件\n")])])]),s("strong",[t._v("file_target")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 目标地址\n")])])]),s("strong",[t._v("案例")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 本地文件上传服务器 scp -r local_folder remote_username@remote_ip:remote_folder\n$ 从服务器下载本地文件 scp -r remote_username@remote_ip:remote_folder local_folder\n\n对拷文件夹 (包括文件夹本身)\n\nscp -r   /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp\n\n对拷文件夹下所有文件 (不包括文件夹本身)\n\nscp   /home/wwwroot/www/charts/util/* root@192.168.1.65:/home/wwwroot/limesurvey_back/scp\n\n对拷文件并重命名\n\nscp   /home/wwwroot/www/charts/util/a.txt root@192.168.1.65:/home/wwwroot/limesurvey_back/scp/b.text\n\n/home/wwwroot/www/charts/util/           本地绝对路径\n\na.txt                                                     要拷贝\n\nroot                                                      通过root用户登录到远程服务器\n\n192.168.1.65                                       远程服务器的ip地址\n\n/home/wwwroot/limesurvey_back/scp  复制到远程服务器上的路径      （注意ip地址后有：）\n\n注:  通常还在后面输入  用户名和密码\n\n将远程服务器上的文件复制到本机\n\n#scp remote@www.abc.com:/usr/local/sin.sh /home/administrator\n\nremote                       通过remote用户登录到远程服务器（也可以使用其他拥有同等权限的用户）\n\nwww.abc.com              远程服务器的域名（当然也可以使用该服务器ip地址）\n\n/usr/local/sin.sh           欲复制到本机的位于远程服务器上的文件\n\n/home/administrator  将远程文件复制到本地的绝对路径\n\n注意两点：\n\n1.如果远程服务器防火墙有特殊限制，scp便要走特殊端口，具体用什么端口视情况而定，命令格式如下：\n\n#scp -p 4588 remote@www.abc.com:/usr/local/sin.sh /home/administrator\n\n2.使用scp要注意所使用的用户是否具有可读取远程服务器相应文件的权限。\n")])])])]),t._v(" "),s("li",[t._v("windows和linux传输文件\n"),s("ol",[s("li",[t._v("下载"),s("code",[t._v("PSCP.exe")]),t._v(",配置Windows的环境变量Path，或者直接通过命令行访问到pscp.exe")]),t._v(" "),s("li",[t._v("把本地文件file传输到Linxu服务器的目录中")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ pscp  -r 本地目录 用户名@LinuxIP:目录\n")])])]),s("ol",{attrs:{start:"3"}},[s("li",[t._v("从Linux向Windows复制文件或目录")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ pscp  -r 用户名@LinuxIP:目录 本地目录\n")])])])])]),t._v(" "),s("h3",{attrs:{id:"服务管理命令-systemctl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务管理命令-systemctl","aria-hidden":"true"}},[t._v("#")]),t._v(" 服务管理命令 systemctl")]),t._v(" "),s("p",[t._v("systemctl 命令有两大类功能：")]),t._v(" "),s("ul",[s("li",[t._v("控制 systemd 系统")]),t._v(" "),s("li",[t._v("管理系统上运行的服务")])]),t._v(" "),s("blockquote",[s("p",[t._v("检查 systemd 的版本\n$ systemctl --version")])]),t._v(" "),s("blockquote",[s("p",[t._v("查看 systemd 和 systemctl 程序相关的目录")])]),t._v(" "),s("p",[t._v("$ whereis systemd\n$ whereis systemctl")]),t._v(" "),s("blockquote",[s("p",[t._v("确认 1 号进程\n作为 init 系统，systemd 进程作为系统中的 1 号进程应该是毋庸置疑的，让我们搜索与 systemd 相关的进程：")])]),t._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110733.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110733.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("结果让人有点不敢相信自己的眼睛，我们搜到了好几个与 systemd 相关的进程，但是却没有 1 号进程。让我们看看 1 号进程是谁：")]),t._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110734.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110734.jpg",alt:""}})]),t._v("\n/sbin/init 是什么？\n"),s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110735.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110735.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("好吧，/sbin/init 只是到 /lib/systemd/systemd 的链接文件，系统的 1 号进程的确是 systemd，只不过在 ubuntu 系统中被起了个别名叫 /sbin/init。")]),t._v(" "),s("blockquote",[s("p",[t._v("管理单个 unit\nsystemctl 提供了一组子命令来管理单个的 unit，其命令格式为：\nsystemctl [command] [unit]\ncommand 主要有：\nstart：立刻启动后面接的 unit。\nstop：立刻关闭后面接的 unit。\nrestart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思。\nreload：不关闭 unit 的情况下，重新载入配置文件，让设置生效。\nenable：设置下次开机时，后面接的 unit 会被启动。\ndisable：设置下次开机时，后面接的 unit 不会被启动。\nstatus：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息。\nis-active：目前有没有正在运行中。\nis-enable：开机时有没有默认要启用这个 unit。\nkill ：不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号。\nshow：列出 unit 的配置。\nmask：注销 unit，注销后你就无法启动这个 unit 了。\nunmask：取消对 unit 的注销。")])]),t._v(" "),s("p",[t._v("我们先通过 prometheus.service 来观察服务类型 unit 的基本信息：\n"),s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110736.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110736.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("输出内容的第一行是对 unit 的基本描述。\n第二行中的 Loaded 描述操作系统启动时会不会启动这个服务，enabled 表示开机时启动，disabled 表示开机时不启动。而启动该服务的配置文件路径为：/lib/systemd/system/prometheus.service。\n第三行 中的 Active 描述服务当前的状态，active (running) 表示服务正在运行中。如果是 inactive (dead) 则表示服务当前没有运行。后面则是服务的启动时间。\n第四行的 Docs 提供了在线文档的地址。\n下面的 Main PID 表示进程的 ID，接下来是任务的数量，占用的内存和 CPU 资源。\n再下面的 Cgroup 描述的是 cgrpup 相关的信息，笔者会在后续的文章中详细的介绍。\n最后是输出的日志信息。")]),t._v(" "),s("p",[t._v("关于 unit 的启动状态，除了 enable 和 disable 之外还有：\nstatic：这个 unit 不可以自己启动，不过可能会被其它的 enabled 的服务来唤醒。\nmask：这个 unit 无论如何都无法被启动！因为已经被强制注销。可通过 systemctl unmask 改回原来的状态。")]),t._v(" "),s("p",[t._v("关于 unit 的运行状态 Active，除了 active 和 inactive 之外还有：\nactive (exited)：仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。举例来说，开机或者是挂载时才会进行一次的 quotaon 功能，就是这种模式！ Quotaon 不需要一直执行，只在执行一次之后，就交给文件系统去自行处理。通常用 bash shell 写的小型服务，大多是属于这种类型。\nactive (waiting)：正在执行当中，不过还再等待其他的事件才能继续处理。举例来说，打印的相关服务就是这种状态。")]),t._v(" "),s("p",[t._v("e> nable 和 disable 操作\n比如我们为 prometheus 服务创建了配置文件 /lib/systemd/system/prometheus.service，然后执行 enable 命令：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ sudo systemctl enable prometheus.service\n\n")])])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110737.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110737.jpg",alt:""}})]),t._v("\n所谓的 enable 就是在 multi-user.target.wants 下面创建了一个链接文件：")]),t._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110838.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110838.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("至于为什么会链接到 multi-user.target.wants 目录下，则是由 prometheus.server 文件中的配置信息决定的。")]),t._v(" "),s("p",[t._v("查看 unit 的配置\n使用 show 子命令可以查看 unit 的详细配置情况：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ sudo systemctl show prometheus.service\n")])])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110839.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110839.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("这里的输出非常多，主要是很多的默认设置也都显示出来了。")]),t._v(" "),s("blockquote",[s("p",[t._v("注销与反注销 unit\n如果我们想暂时的禁用某个 unit，比如 prometheus.service，可以注销这个 unit，注销之后就无法再启动这个服务了：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ sudo systemctl mask prometheus.service\n")])])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110840.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110840.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("从上图中的输出我们可以看到，所谓的注销就是把 prometheus.service 文件链接到 /dev/null 这个空设备中去了。所以就无法再启动该服务了。下面我们尝试执行一次反注销：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ sudo systemctl unmask prometheus.service\n")])])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110841.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110841.jpg",alt:""}})]),t._v("\nunmask 操作就是删除掉 mask 操作中创建的链接。")]),t._v(" "),s("blockquote",[s("p",[t._v("查看系统上的 unit\nsystemctl 提供了子命令可以查看系统上的 unit，命令格式为：\nsystemctl [command] [--type=TYPE] [--all]\ncommand 有：\nlist-units：列出当前已经启动的 unit，如果添加 -all 选项会同时列出没有启动的 unit。\nlist-unit-files：根据 /lib/systemd/system/ 目录内的文件列出所有的 unit。\n--type=TYPE：可以过滤某个类型的 unit。\n不带任何参数执行 systemctl 命令会列出所有已启动的 unit：")])]),t._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110842.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110842.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("系统默认启动的服务是非常多的，上图只截取了前面几行。下面是对输出的介绍：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("UNIT：项目的名称，包括各个 unit 的类别(看扩展名)。\nLOAD：开机时 unit 的配置是否被加载。\nACTIVE：目前的状态，须与后续的 SUB 搭配！就是我们用 systemctl status 观察时，active的内容。\nDESCRIPTION：描述信息。\n注意，systemctl 不加参数，其实等同于 systemctl list-units！\n")])])]),s("p",[t._v("下面我们查看系统上一共安装了多少 unit：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ sudo systemctl list-unit-files\n")])])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110843.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110843.jpg",alt:""}})]),t._v("\n结果也非常的多，我们仍然只截取一部分结果。这里的 STATE 就是我们前面介绍的 服务的启动状态，有 enable 和 disable、static 和 mask。")]),t._v(" "),s("blockquote",[s("p",[t._v("只查看某种类型的 unit\n比如我们只想看服务类型的 unit：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ systemctl list-units --type=service --all\n")])])]),s("p",[t._v("这次只有以 .service 结尾的 unit 才会出现。\n如果要看 mount 类型的 unit 指定 --type=mount 就可以了：")]),t._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110844.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110844.jpg",alt:""}})])]),t._v(" "),s("blockquote",[s("p",[t._v("查看加载失败的 unit\n如果发现某个 unit 不工作，可以查看是否有 unit 加载失败：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ systemctl --failed\n")])])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110845.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110845.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("管理不同的操作环境(target unit)\n通过指定 --type=target 就可以用 systemctl list-units 命令查看系统中默认有多少种 target：\n"),s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110946.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110946.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("笔者的 ubuntu 16.04 中居然有 27 个 target！我们在此仅介绍几个常用的 target。\ngraphical.target：就是文字界面再加上图形界面，这个 target 已经包含了下面的 multi-user.target。\nmulti-user.target：纯文本模式！\nrescue.target：在无法使用 root 登陆的情况下，systemd 在开机时会多加一个额外的临时系统，与你原本的系统无关。这时你可以取得 root 的权限来维护你的系统。\nemergency.target：紧急处理系统的错误，在无法使用 rescue.target 时，可以尝试使用这种模式！\nshutdown.target：就是执行关机。\ngetty.target：可以设置 tty 的配置。\n正常的模式是 multi-user.target 和 graphical.target 两个，救援方面的模式主要是 rescue.target 以及更严重的 emergency.target。如果要修改可提供登陆的 tty 数量，则修改 getty.target。")]),t._v(" "),s("p",[t._v("下面是操作 target unit 命令的格式：\nsystemctl [command] [unit.target]\ncommand 有：\nget-default：取得目前的 target。\nset-default：设置后面接的 target 成为默认的操作模式。\nisolate：切换到后面接的模式。")]),t._v(" "),s("blockquote",[s("p",[t._v("查看和设置默认的 target")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ sudo systemctl get-default\n")])])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110947.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110947.jpg",alt:""}})]),t._v("\n笔者系统的默认 target 为 graphical.target，所以启动时默认启动图形界面。下面我们把它设置为 multi-user.target：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ sudo systemctl set-default multi-user.target\n")])])]),s("p",[t._v("实际的执行过程是删除之前的链接文件，然后创建新的到 /lib/systemd/system/multi-user.target 的链接文件。这样下次开机时默认会进入纯文本模式。\n"),s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110948.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110948.jpg",alt:""}})])]),t._v(" "),s("blockquote",[s("p",[t._v("切换 target\n我们还可以在不重新启动的情况下切换不同的 target，比如从图形界面切换到纯文本的模式：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ sudo systemctl isolate multi-user.target\n")])])]),s("p",[t._v("在一般情况下，使用上述 isolate 的方式即可完成不同 target 的切换。不过为了方便起见，systemd 也提供了\n几个简单的指令用来切换操作模式，大致如下所示：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ sudo systemctl poweroff  # 系统关机\n$ sudo systemctl reboot    # 重新开机\n$ sudo systemctl suspend   # 进入暂停模式\n$ sudo systemctl hibernate  # 进入休眠模式\n$ sudo systemctl rescue    # 强制进入救援模式\n$ sudo systemctl emergency # 强制进入紧急救援模式\n")])])]),s("p",[t._v("这里简单介绍一下暂停模式与休眠模式的区别\nsuspend：暂停模式会将系统的状态保存到内存中，然后关闭掉大部分的系统硬件，当然，并没有实际关机。当用户按下唤醒机器的按钮，系统数据会从内存中回复，然后重新驱动被大部分关闭的硬件，所以唤醒系统的速度比较快。\nhibernate：休眠模式则是将系统状态保存到硬盘当中，保存完毕后，将计算机关机。当用户尝试唤醒系统时，系统会开始正常运行，然后将保存在硬盘中的系统状态恢复回来。因为数据需要从硬盘读取，因此唤醒的速度比较慢(如果你使用的是 SSD 磁盘，唤醒的速度也是非常快的)。")]),t._v(" "),s("p",[t._v("检查 unit 之间的依赖性\n很多服务之间是有依赖关系的，systemd 的一大亮点就是可以管理 unit 之间的依赖关系。我们可以通过下面的命令来查看 unit 间的依赖关系：\nsystemctl list-dependencies [unit] [--reverse] 选项 --reverse 会反向追踪是谁在使用这个 unit。\n下面让我们看看当前运行的 target 的依赖关系：")]),t._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110949.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110949.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("我们当前运行在 graphical.target 下，它由一个长长的依赖列表(上图并未展示所有的项目)，其中最重要的依赖项目为 multi-user.target。下面我们使用 --reverse 选项查看 multi-user.target unit 被谁使用：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ systemctl list-dependencies multi-user.target --reverse\n")])])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110950.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110950.jpg",alt:""}})])]),t._v(" "),s("p",[t._v("从上面两张图上我们可以确定下面的关系：graphical.target 依赖 multi-user.target。\n我们这里只是通过 target unit 介绍了如何查看 unit 之间的依赖关系，实际使用中更多的是检查服务 unit 之间的依赖关系。")]),t._v(" "),s("blockquote",[s("p",[t._v("相关的目录和文件\n在不同的发行版中与 systemd 相关的文件路径可能会不太一样，强调一下，本文介绍的是 ubuntu 16.04 。\n/lib/systemd/system/ 大多数 unit 的配置文件都放在这个目录下。\n/run/systemd/system/ 系统运行过程中产生的脚本，比如用户相关的脚本和会话相关的脚本。\n/etc/systemd/system/ 这个目录中主要的文件都是指向 /lib/systemd/system/ 目录中的链接文件。\n注意，在我们自己创建 unit 配置文件时，既可以把配置文件放在 /lib/systemd/system/ 目录下，也可以放在 /etc/systemd/system/ 目录下。")])]),t._v(" "),s("p",[t._v("/etc/default/ 这个目录中放置很多服务默认的配置文件。\n/var/lib/ 一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中，比如 docker 相关的数据文件就放在这个目录下。\n/run/ 这个目录放置了好多服务运行时的临时数据，比如 lock file 以及 PID file 等等。")]),t._v(" "),s("p",[t._v("我们知道 systemd 里管理了很多会用到本机 socket 的服务，所以系统中肯定会产生很多的 socket 文件。那么，这些 socke 文件都存放在哪里呢？我们可以使用 systemctl 进行查看：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ systemctl list-sockets\n")])])]),s("p",[s("a",{attrs:{"data-fancybox":"",title:"",href:"https://files.jb51.net/file_images/article/201803/2018031611110951.jpg"}},[s("img",{attrs:{src:"https://files.jb51.net/file_images/article/201803/2018031611110951.jpg",alt:""}})]),t._v("\n其实，绝大多数的 socket 文件都存放在 /run 目录及其子目录中。")]),t._v(" "),s("blockquote",[s("p",[t._v("systemctl daemon-reload 子命令\ndaemon-reload 是一个很容易被误用的子命令，主要是因为它名字中包含的 daemon 一词很容易让它和 reload 子命令混淆。\n我们在前文简略的介绍了 reload 子命令，它的作用是重新加载某个服务程序的配置文件。这里的程序指的是服务类型 unit 的配置中指定的程序，也就是我们常说的 daemon(提供某种服务的应用程序)。比如服务类型的 unit prometheus.service，提供服务的 daemon 程序在我的机器上是 /usr/local/share/prometheus/prometheus，所以 reload 子命令重新加载的是 prometheus 的配置文件。")])]),t._v(" "),s("p",[t._v("如果把 daemon-reload 子命令中的 daemon 理解为 systemd 程序，就可以把这个命令解释为重新加载 systemd 程序的配置文件。而所有的 unit 配置文件都是作为 systemd 程序的配置文件存在的。这样得出的结论就是：")]),t._v(" "),s("p",[t._v("新添加 unit 配置文件时需要执行 daemon-reload 子命令\n有 unit 的配置文件发生变化时也需要执行 daemon-reload 子命令\ndaemon-reload 命令会做很多的事情，其中之一是重新生成依赖树(也就是 unit 之间的依赖关系)，所以当你修改了 unit 配置文件中的依赖关系后如果不执行 daemon-reload 命令是不会生效的。")]),t._v(" "),s("h3",{attrs:{id:"_6-网络通讯"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-网络通讯","aria-hidden":"true"}},[t._v("#")]),t._v(" 6.网络通讯")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("ifconfig 查看或设置网卡")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("启动关闭指定网卡\n$ ifconfig eth0 down\n$ ifconfig eth0 up\n重启网卡服务\n$ service network restart\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("配置IP地址\n$ ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255\n")])])])]),t._v(" "),s("li",[s("p",[t._v("netstat   利用netstat指令可让你得知整个Linux系统的网络情况")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("显示UDP端口号的使用情况\n$ netstat -apu\n\n$ netstat -ltunp\n")])])]),s("p",[t._v("关闭httpd服务： service httpd stop")])]),t._v(" "),s("li",[s("p",[t._v("ping  用于检测主机")])]),t._v(" "),s("li",[s("p",[t._v("ssh")])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.登录                   \n       ssh -p22 omd@192.168.25.137               \n   2.直接执行命令  --\x3e最好全路径                   \n       ssh root@192.168.25.137 ls -ltr /backup/data                       \n           ==>ssh root@192.168.25.137 /bin/ls -ltr /backup/data               \n   3.查看已知主机                    \n        cat /root/.ssh/known_hosts\n   4.ssh远程执行sudo命令\n       ssh -t omd@192.168.25.137 sudo rsync hosts /etc/\n \n   5.scp               \n             1.功能   --\x3e远程文件的安全(加密)拷贝                   \n                 scp -P22 -r -p /home/omd/h.txt omd@192.168.25.137:/home/omd/               \n             2.scp知识小结                   \n                 scp是加密远程拷贝，cp为本地拷贝                   \n                 可以推送过去，也可以拉过来                   \n                 每次都是全量拷贝(效率不高，适合第一次)，增量拷贝用rsync\n \n   6.ssh自带的sftp功能               \n             1.Window和Linux的传输工具                   \n                  wincp   filezip                   \n               sftp  --\x3e基于ssh的安全加密传输                   \n               samba   \n             2.sftp客户端连接                   \n                sftp -oPort=22 root@192.168.25.137                   \n                put /etc/hosts /tmp                   \n                get /etc/hosts /home/omd   \n            3.sftp小结：                   \n                1.linux下使用命令： sftp -oPort=22 root@x.x.x.x                   \n                2.put加客户端本地路径上传                  \n                3.get下载服务器端内容到本地                   \n                4.远程连接默认连接用户的家目录\n")])])]),s("ul",[s("li",[t._v("关于后台ssh服务的相关")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('# 查询openssl软件\n    rpm -qa openssh openssl\n# 查询sshd进程\n    ps -ef | grep ssh\n        --\x3e /usr/sbin/sshd\n# 查看ssh端口\n    netstat -lntup | grep ssh  \n    ss | grep ssh                (效果同上，同下，好用)\n    netstat -a | grep ssh(记住这个)\n    netstat -lnt | grep 22    ==>  查看22端口有没有开/ssh服务有没有开启\n    技巧： netstat -lnt | grep ssh | wc -l --\x3e只要大于2个就是ssh服务就是好的\n# 查看ssh的秘钥目录\n    ll /root/.ssh/known_hosts  # 当前用户家目录的.ssh目录下\n# ssh的配置文件\n    cat /etc/ssh/sshd_config   \n# ssh服务的关闭\n    service sshd stop\n# ssh服务的开启：\n    service sshd start\n# ssh服务的重启\n    service sshd reload    [停止进程后重启] ==> 推荐\n    service sshd restart   [干掉进程后重启] ==> 不推荐\n# ssh远程登录\n    ssh 192.168.1.100      # 默认利用当前宿主用户的用户名登录\n    ssh omd@192.168.1.100  # 利用远程机的用户登录\n    ssh omd@192.168.1.100  -o stricthostkeychecking=no # 首次登陆免输yes登录\n    ssh omd@192.168.1.100 "ls /home/omd"  # 当前服务器A远程登录服务器B后执行某个命令\n    ssh omd@192.168.1.100 -t "sh /home/omd/ftl.sh"  # 当前服务器A远程登录服务器B后执行某个脚本\n')])])]),s("h3",{attrs:{id:"_7-权限管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-权限管理","aria-hidden":"true"}},[t._v("#")]),t._v(" 7.权限管理")]),t._v(" "),s("ul",[s("li",[t._v("sudo -s")]),t._v(" "),s("li",[t._v("whoami 查看当前用户")]),t._v(" "),s("li",[t._v("who 查看所有登陆用户")]),t._v(" "),s("li",[t._v("echo $USER 查看当前用户")]),t._v(" "),s("li",[t._v("useradd (选项) (参数)\n"),s("strong",[t._v("选项")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -d 指定用户登入时的启始目录\n$ -m 自动建立用户的登入目录\n$ -g 指定用户所属的群组\n$ -G 追加用户所属的群组\n")])])]),s("strong",[t._v("参数")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 用户名\n$ user add -d aaa -m aaa -g aaa username\n")])])])]),t._v(" "),s("li",[t._v("usermod  修改用户")]),t._v(" "),s("li",[t._v("passwd 修改密码")]),t._v(" "),s("li",[t._v("su    切换账户")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("切换超级管理员时需要需要输入密码\n普通账户这不需要\n")])])]),s("ul",[s("li",[s("p",[t._v("userdel (参数) (选项)\n"),s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -f 强制删除\n\n")])])]),s("p",[s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ 要删除的用户名\n$ userdel -f username\n")])])])]),t._v(" "),s("li",[s("p",[t._v("groupadd (组名) 添加一个用户组")])]),t._v(" "),s("li",[s("p",[t._v("groupamod (选项) (参数) 修改用户组的信息\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -g<群组识别码>：设置欲使用的群组识别码；\n$ -n<新群组名称>：设置欲使用的群组名称。\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("组名：指定要修改的工作的组名。\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("让改用户组拥有sudo的功能\n$ groupmod -a -G sudo groupname\n$ groupmod -a -G adm  groupname\n")])])])]),t._v(" "),s("li",[s("p",[t._v("gpasswd (参数) (用户) (组) 将用户从用户组中添加或删除\n"),s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -a : 添加用户到组\n$ -d : 从组删除用户\n$ gpasswd -a userA groupA\n")])])])]),t._v(" "),s("li",[s("p",[t._v("groupadel 删除用户组")])]),t._v(" "),s("li",[s("p",[t._v("groups 查看当前用户所属的用户组")])]),t._v(" "),s("li",[s("p",[t._v("chgrp (选项) (参数) 用来改变文件或目录所属的用户组\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ -R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；\n$ chgrp -R groupname /usr/meng\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("组：指定新工作名称；\n文件：指定要改变所属组的文件列表。多个文件或者目录之间使用空格隔开。\n")])])])]),t._v(" "),s("li",[s("p",[t._v("chmod (选项) (参数)\n"),s("strong",[t._v("选项")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是\n$ r 表示可读取 4，w 表示可写入 2，x 表示可执行 1\n$ -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("rwx r读4 w写2 x执行1\nchmod u=rwx g=rwx o=rwx\n$ chmod u=rwx,g=rw,o=r file\n")])])])]),t._v(" "),s("li",[s("p",[t._v("chattr")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('chattr可以防止关键文件被修改\n在linux下，有些配置文件是不允许任何人包括root修改的，为了防止被误删除或修改，\n可以设定该文件的"不可修改位(immutable)"。\n\n例如：\nchattr +i /etc/fstab\n如果需要修改文件则：\nchattr -i /etc/fstab\n以后再修改文件。\n\n')])])])])]),t._v(" "),s("h3",{attrs:{id:"_8-软件安装和管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-软件安装和管理","aria-hidden":"true"}},[t._v("#")]),t._v(" 8.软件安装和管理")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("APT (Advanced Package Tool,高级软件包工具) 是一个强大的包管理系统，而那些图形化程序如 添加/删除 应用程序 和 Synaptic 都是建立在它的基础之上的。APT 自动处理依赖关系并在系统软件包执行其他操作以便安装所要的软件包")])]),t._v(" "),s("li",[s("p",[t._v("添加包地址:")]),t._v(" "),s("ul",[s("li",[t._v("sudo add-apt-repository ppa:webupd8team/java")]),t._v(" "),s("li",[t._v("如果没有 add-apt-repository 这个命令，运行 sudo apt-get install software-properties-common python-software-properties")]),t._v(" "),s("li",[t._v("ppa 全称为Personal Package Archives(个人软件包档案),是UbuntuLaunchpad网站提供的一项服务")])])]),t._v(" "),s("li",[s("p",[t._v("安装软件包：")]),t._v(" "),s("ul",[s("li",[t._v("sudo apt-get install packagename")])])]),t._v(" "),s("li",[s("p",[t._v("删除软件包：")]),t._v(" "),s("ul",[s("li",[t._v("sudo apt-get remove packagename")])])]),t._v(" "),s("li",[s("p",[t._v("删除软件包包括配置文件")]),t._v(" "),s("ul",[s("li",[t._v("apt-get --purge remove mysql-server mysql-client")])])]),t._v(" "),s("li",[s("p",[t._v("删除该软件的依赖包")]),t._v(" "),s("ul",[s("li",[t._v("apt-get autoremove mysql-server mysql-client")])])]),t._v(" "),s("li",[s("p",[t._v("清理无用的包")]),t._v(" "),s("ul",[s("li",[t._v("sudo apt-get clean && sudo apt-get autoclean")])])]),t._v(" "),s("li",[s("p",[t._v("获取新的软件包列表：")]),t._v(" "),s("ul",[s("li",[t._v("sudo apt-get update")])])]),t._v(" "),s("li",[s("p",[t._v("升级有可用更新的系统：")]),t._v(" "),s("ul",[s("li",[t._v("sudo apt-get upgrade")])])]),t._v(" "),s("li",[s("p",[t._v("下载该包的源代码")]),t._v(" "),s("ul",[s("li",[t._v("apt-get source package")])])]),t._v(" "),s("li",[s("p",[t._v("列出更多命令和选项：")]),t._v(" "),s("ul",[s("li",[t._v("apt-get help")])])])]),t._v(" "),s("h3",{attrs:{id:"_9-其他常用系统命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-其他常用系统命令","aria-hidden":"true"}},[t._v("#")]),t._v(" 9. 其他常用系统命令")]),t._v(" "),s("ul",[s("li",[t._v("关机"),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ halt 立刻关机\n$ poweroff 立刻关机\n$ shutdown -h now 立刻关机(root用户使用)\n$ shutdown -h 10 10分钟后自动关机\n")])])])]),t._v(" "),s("li",[t._v("重启"),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ reboot\n$ shutdown -r now\n$ shutdown -r now 10\n$ shutdown -r 20:35\n$ shutdown -c 取消重启\n")])])])]),t._v(" "),s("li",[t._v("进程"),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("ps -aux  显示所有包含使用者的进程\ntop 动态显示所有进程\nkill pid  杀死进程\nkill -9 pid  强制杀死进程\n")])])])])]),t._v(" "),s("h3",{attrs:{id:"_10-vi-vim编辑器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-vi-vim编辑器","aria-hidden":"true"}},[t._v("#")]),t._v(" 10.vi\\vim编辑器")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("vi <filename>     # 无则创建，有则编辑\nvi -o file1 file2 # 以分屏的方式打开两个文件\nEsc               # 退出到命令模式\ni                 # 进入插入模式\n:                 # 进入命令模式\nZZ || :wq         # 保存修改并退出\n:w                # 只保存文件\n:q!               # 放弃所有文件的修改并退出 强制退出\n:e!               # 放弃更改，但不退出\n")])])]),s("h3",{attrs:{id:"_11-安装-pycharm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-安装-pycharm","aria-hidden":"true"}},[t._v("#")]),t._v(" 11.安装 pycharm")]),t._v(" "),s("pre",[s("code",[t._v('```\n1. 安装java运行环境\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java8-installer\n2. 运行命令\njava -version\njavac -version\n如果以上两个命令找不到的话，执行第二步，否则跳过第三步\n3. 添加全局变量\necho JAVA_HOME="/usr/lib/jvm/java-8-oracle" >> /etc/environment\nsource /etc/environment\n4. 安装pycharm\n到pycharm官网下载在linux的安装包\n解压\n\n并且运行 bin/pycharm.sh\n$ sudo sh pycharm/bin/pychar.sh\n\n5. 破解\n到http://idea.lanyus.com/网站获取注册码\n6. 创建快捷方式\n- Ubuntu的快捷方式都放在/usr/share/applications，首先在该目录下创建一个Pycharm.desktop\n- 在 该文件写入以下配置：\n[Desktop Entry]\nType=Application\nName=Pycharm\nGenericName=Pycharm3\nComment=Pycharm3:The Python IDE\nExec="/XXX/pycharm/bin/pycharm.sh" %f\nIcon=/XXX/pycharm/bin/pycharm.png\nTerminal=pycharm\nCategories=Pycharm;\n- 锁定到启动器\n```\n')])]),t._v(" "),s("h3",{attrs:{id:"_12-ubuntu修改时区和时间的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-ubuntu修改时区和时间的方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 12.ubuntu修改时区和时间的方法")]),t._v(" "),s("pre",[s("code",[t._v("```\n参考： https://blog.csdn.net/YEYUANGEN/article/details/52103445\n```\n")])]),t._v(" "),s("h2",{attrs:{id:"winow常用的命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#winow常用的命令","aria-hidden":"true"}},[t._v("#")]),t._v(" Winow常用的命令")]),t._v(" "),s("p",[t._v("dir         列文件名")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("显示目录文件和子目录列表\n　　可以使用通配符（? 和 *），？表通配一个字符，*表通配任意字符\n　　*.后缀\n　　指定要查看后缀的文件。 上面其实也可以为“ . 后缀”,例如dir *.exe 等于dir .exe\n　　/p\n　　每次显示一个列表屏幕。要查看下一屏，请按键盘上的任意键。\n　　/w\n　　以宽格式显示列表，在每一行上最多显示 5 个文件名或目录名。\n　　/s\n　　列出指定目录及所有子目录中出现的每个指定的文件名。比win环境下的查找快多了\n　　dir *.* -> a.txt 把当前目录文件列表写入a.txt\n　　dir *.* /s -> a.txt 把当前目录文件列表写入a.txt，包括子目录下文件。\n")])])]),s("p",[t._v("deltree     删除目录树"),s("br"),t._v("\ncls         清屏"),s("br"),t._v("\ncd          改变当前目录。/去根目录"),s("br"),t._v("\ncopy        拷贝文件         例：copy 要复制的文件 复制以后的文件与目录"),s("br"),t._v("\nrename     更改文件名    例：rename 要改的文件 更改后的文件名"),s("br"),t._v("\ndiskcopy    复制磁盘"),s("br"),t._v("\ndel         删除文件 （不会出现在回收站中）"),s("br"),t._v("\nformat      格式化磁盘。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("　/q 执行快速格式化。删除以前已格式化卷的文件表和根目录，但不在扇区之间扫描损坏区域。使用 /q 命令行选项应该仅格式化以前已格式化的完好的卷\n")])])]),s("p",[t._v("Ipconfig")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("显示所有当前的 TCP/IP 网络配置值、刷新动态主机配置协议 (DHCP) 和域名系统 (DNS) 设置。使用不带参数的 ipconfig 可以显示所有适配器的 IP 地址、子网掩码、默认网关。\n　　/all 显示所有适配器的完整 TCP/IP 配置信息。\n　　ipconfig 等价于 winipcfg，后者在ME、98 和 95 上可用。尽管 Windows XP 没有提供象 winipcfg 命令一样的图形化界面，但可以使用“网络连接”查看和更新 IP 地址。要做到这一点，请打开 网络连接，右键单击某一网络连接，单击“状态”，然后单击“支持”选项卡。\n　　该命令最适用于配置为自动获取 IP 地址的计算机。它使用户可以确定哪些 TCP/IP 配置值是由 DHCP、自动专用 IP 地址 (APIPA) 和其他配置配置的。\n")])])]),s("p",[t._v("edit        文本编辑"),s("br"),t._v("\nmem         查看内存状况"),s("br"),t._v("\nmd          建立子目录"),s("br"),t._v("\nmove        移动文件、改目录名。"),s("br"),t._v("\nmore        分屏显示"),s("br"),t._v("\ntype        显示文件内容"),s("br"),t._v("\nrd          删除目录"),s("br"),t._v("\nsys         制作DOS系统盘。"),s("br"),t._v("\nren         改变文件名"),s("br"),t._v("\nxcopy       拷贝目录与文件"),s("br"),t._v("\nchkdsk      检查磁盘"),s("br"),t._v("\nattrib      设置文件属性。"),s("br"),t._v("\nExit        退出当前命令解释程序并返回到系统。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("　显示、设置或删除指派给文件或目录的只读、存档、系统以及隐藏属性。如果在不含参数的情况下使用，则 attrib 会显示当前目录中所有文件的属性。\n　　+r 设置只读属性。\n　　-r 清除只读属性。\n　　+a 设置存档文件属性。\n　　-a 清除存档文件属性。\n　　+s 设置系统属性。\n　　-s 清除系统属性。\n　　+h 设置隐藏属性。\n　　-h 清除隐藏属性\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("fdisk       硬盘分区\ndate        显示及修改日期 \nlabel       设置卷标号\ndefrag      磁盘碎片整理。\nmsd         系统检测 \npath        设置搜寻目录 \nshare       文件共享\nmemmaker    内存优化管理。\nhelp        帮助\nrestore     恢复备份文件 \nset         设置环境变量\ntime        显示及修改时间。\ntree        列目录树\ndebug       随机调试程序 \ndoskey      重新调用DOS命令\nprempt      设置提示符\nundelete    恢复被删的文件 \nscandisk    检测、修理磁盘。\n\n")])])]),s("h2",{attrs:{id:"cygwin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cygwin","aria-hidden":"true"}},[t._v("#")]),t._v(" Cygwin")]),t._v(" "),s("p",[t._v("在window用Linux命令")]),t._v(" "),s("p",[t._v("注意：Linux 只有一个盘符")]),t._v(" "),s("h3",{attrs:{id:"web服务器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#web服务器","aria-hidden":"true"}},[t._v("#")]),t._v(" web服务器")]),t._v(" "),s("p",[t._v("负载主机器进行分发，找到离自己最近的小机器，进行localhost（127.0.0.1）\n输入链接后->通过DNS服务查找到ip地址进行连接。")]),t._v(" "),s("p",[t._v("window：IIS   /   Apache\n1、XAMPP：基于php的开发环境 （推荐）\n注意：安装的时候以管理员的身份运行，否则会报错\n因为需要往电脑里面安服务，需要各种权限")]),t._v(" "),s("p",[t._v("2、IIS：windows运行平台的服务器\n控制面板==>程序和功能==>打开或关闭windows功能==>internet信息服务（服务器\t\t相关扩展，FTP:上传文件到远程）")])])},[],!1,null,null,null);a.default=n.exports}}]);